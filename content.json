{"meta":{"title":"Kevin's Blog","subtitle":"Stay Foolish. Stay Hungry.","description":null,"author":"Kevin","url":"http://kevingeek.github.io","root":"/"},"pages":[{"title":"404","date":"1969-12-31T16:00:00.000Z","updated":"2020-04-17T14:51:23.069Z","comments":true,"path":"404/index.html","permalink":"http://kevingeek.github.io/404/index.html","excerpt":"","text":""},{"title":"åˆ†ç±»","date":"2020-04-17T13:03:23.000Z","updated":"2020-04-17T13:48:19.622Z","comments":false,"path":"categories/index.html","permalink":"http://kevingeek.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-04-17T12:19:40.000Z","updated":"2020-04-17T13:48:17.125Z","comments":false,"path":"tags/index.html","permalink":"http://kevingeek.github.io/tags/index.html","excerpt":"","text":""},{"title":"schedule","date":"2020-04-17T12:38:24.000Z","updated":"2020-04-17T12:38:45.715Z","comments":true,"path":"schedule/index.html","permalink":"http://kevingeek.github.io/schedule/index.html","excerpt":"","text":""}],"posts":[{"title":"Javaå¸¸ç”¨è¯Šæ–­å·¥å…·","slug":"Javaå¸¸ç”¨è¯Šæ–­å·¥å…·","date":"2020-04-15T19:14:10.000Z","updated":"2020-04-17T16:24:20.488Z","comments":true,"path":"2020/04/16/Javaå¸¸ç”¨è¯Šæ–­å·¥å…·/","link":"","permalink":"http://kevingeek.github.io/2020/04/16/Java%E5%B8%B8%E7%94%A8%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/","excerpt":"å¼€å‘è¿‡ç¨‹ä¸­å¹³æ—¶ç»å¸¸ç”¨çš„ä¸€äº›å°å·¥å…·","text":"å¼€å‘è¿‡ç¨‹ä¸­å¹³æ—¶ç»å¸¸ç”¨çš„ä¸€äº›å°å·¥å…· Javaç›¸å…³å‘½ä»¤å¸¸ç”¨çš„å‘½ä»¤ï¼š jstacké€šå¸¸æ¥è¯´ï¼Œå¦‚æœå‡ºç°ç¨‹åºå¡æ­»äº†ï¼ˆæ¯”å¦‚restart tomcatçš„æ—¶å€™ï¼‰ï¼Œä¸çŸ¥é“å¡å“ªå„¿äº†ï¼Œå’‹åŠå‘¢ï¼Œç”¨jstackçœ‹ä¸€ä¸‹å“ªä¸ªçº¿ç¨‹åœ¨å¹²äº‹ 1jstack -l $(pid) jstatè¿™ä¸ªè²Œä¼¼å°±æ˜¯ç”¨æ¥çœ‹gcçš„ã€‚ã€‚å¹³æ—¶ä¸€èˆ¬å…¶ä»–çš„ä¹Ÿéƒ½ç”¨ä¸ä¸Šå•Š 1jstat [-å‘½ä»¤é€‰é¡¹] [vmid] [é—´éš”æ—¶é—´/æ¯«ç§’] [æŸ¥è¯¢æ¬¡æ•°] jmapåŸºæœ¬ä¸Šï¼Œç”¨åˆ°äº†jmapå°±æ˜¯å†…å­˜æ³„æ¼äº†å¸¸ç”¨å‘½ä»¤ 1jmap -histo $(pid) jcmd å‘é€è¯Šæ–­å‘½ä»¤ï¼Œä¼¼ä¹å•¥éƒ½èƒ½å¹²ï¼Œå‘é€helpå‘½ä»¤ï¼Œå¯ä»¥åŸºæœ¬çœ‹ä¸€äº›èƒ½å¹²çš„äº‹ 1jcmd $(pid) help jmcjmcå…¶å®å°±æœ‰ç‚¹æ„æ€ï¼Œè¯´ç™½äº†æ˜¯ä¸€ä¸ªç‰¹æ€§ï¼Œé…åˆå’Œjfrä½¿ç”¨ï¼Œ ç³»ç»Ÿç›¸å…³çš„å‘½ä»¤freeçœ‹å†…å­˜çš„å¸¸ç”¨å‘½ä»¤ï¼Œçœ‹ä¸€ä¸‹æ€»å†…å­˜ã€å·²ç”¨å†…å­˜ã€ç©ºé—²å†…å­˜ã€å…±äº«å†…å­˜ã€buff/cacheå†…å­˜å’Œå¯ç”¨å†…å­˜çš„å¤§å°ä»¥åŠswapåˆ†åŒºçš„å¤§å°ï¼ˆå¯ä»¥çœ‹åˆ°ï¼Œæˆ‘çš„æœºå™¨ä¸Šswapåˆ†åŒºå¤§å°ä¸º0ï¼Œå°±æ˜¯è¯´ä¸ä¼šäº§ç”Ÿswapï¼Œç›´æ¥OOMï¼Œé¿å…äº§ç”Ÿswapæœºåˆ¶å¸¦æ¥çš„IOç“¶é¢ˆé—®é¢˜ï¼‰ 1234[kevin@ky1 ~]$ free -h total used free shared buff/cache availableMem: 3.7Gi 823Mi 360Mi 0.0Ki 2.5Gi 2.6GiSwap: 0B 0B 0B toptopå‘½ä»¤ï¼Œé›†å¤§æˆï¼Œä¸å±•å¼€è¯´äº† 12345678910111213[kevin@ky1 ~]$ toptop - 23:16:12 up 12 days, 4:16, 1 user, load average: 0.13, 0.04, 0.01Tasks: 105 total, 1 running, 104 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.0 us, 3.2 sy, 0.0 ni, 96.8 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stMiB Mem : 3780.8 total, 360.5 free, 823.7 used, 2596.6 buff/cacheMiB Swap: 0.0 total, 0.0 free, 0.0 used. 2691.2 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 3084 root 10 -10 180812 37704 15780 S 6.7 1.0 219:32.13 AliYunDun 1 root 20 0 178540 10912 8004 S 0.0 0.3 0:12.98 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.26 kthreadd 3 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 rcu_gp 4 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 rcu_par_gp pmapåˆšå¥½åœ¨ç½‘ä¸ŠæŸ¥åˆ°ä¸€ä¸ªç‰¹åˆ«å¥½çš„ä¾‹å­è¿™é‡Œå…¶å®åˆšå¥½é‡åˆ°ä¸€ä¸ªç‰¹åˆ«å¥½çš„ä¾‹å­å¼€å§‹ç”¨NMTå’Œpmapæ¥è¿›è¡Œåˆ†æå†…å­˜çš„åˆ†å¸ƒï¼Œè¿™é‡Œå¯¹äºjvmçš„å†…å­˜ï¼Œå’ŒçœŸæ­£ä¸€ä¸ªè¿›ç¨‹é”å¯¹åº”çš„å®é™…å†…å­˜æ˜¯å¦‚ä½•åˆ†å¸ƒçš„ï¼Œæœ‰ä¸€ä¸ªç‰¹åˆ«æ·±å…¥ç›´è§‚çš„ç†è§£ ä¸‹é¢æ˜¯ä¸€ä¸ªpmapçš„ä¸€ä¸ªåŸºç¡€è¾“å‡ºï¼Œï¼ˆç‰ˆæœ¬ä¸åŒå¯èƒ½è¾“å‡ºä¸ä¸€æ ·ï¼‰ 123START SIZE RSS PSS DIRTY SWAP PERM MAPPING00000000d54aa000 92824K 92824K 92824K 92824K 0K rw-p [anon]00000000daf50000 174784K 174784K 174784K 174784K 0K rw-p [anon] ç„¶åå¯¹æ¯”ä¸€ä¸‹ NMT çš„è¾“å‡º 1jcmd 14179 VM.native_memory detail 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697014179:Native Memory Tracking:Total: reserved=653853KB, committed=439409KB- Java Heap (reserved=262144KB, committed=262144KB) (mmap: reserved=262144KB, committed=262144KB)- Class (reserved=82517KB, committed=81725KB) (classes #17828) (malloc=1317KB #26910) (mmap: reserved=81200KB, committed=80408KB)- Thread (reserved=20559KB, committed=20559KB) (thread #58) (stack: reserved=20388KB, committed=20388KB) (malloc=102KB #292) (arena=69KB #114)- Code (reserved=255309KB, committed=41657KB) (malloc=5709KB #11730) (mmap: reserved=249600KB, committed=35948KB)- GC (reserved=1658KB, committed=1658KB) (malloc=798KB #676) (mmap: reserved=860KB, committed=860KB)- Compiler (reserved=130KB, committed=130KB) (malloc=31KB #357) (arena=99KB #3)- Internal (reserved=5039KB, committed=5039KB) (malloc=5007KB #20850) (mmap: reserved=32KB, committed=32KB)- Symbol (reserved=18402KB, committed=18402KB) (malloc=14972KB #221052) (arena=3430KB #1)- Native Memory Tracking (reserved=2269KB, committed=2269KB) (malloc=53KB #1597) (tracking overhead=2216KB)- Arena Chunk (reserved=187KB, committed=187KB) (malloc=187KB)- Unknown (reserved=5640KB, committed=5640KB) (mmap: reserved=5640KB, committed=5640KB) . . .Virtual memory map:[0xceb00000 - 0xcec00000] reserved 1024KB for Class from[0xced00000 - 0xcee00000] reserved 1024KB for Class from. . .[0xcf85e000 - 0xcf8af000] reserved and committed 324KB for Thread Stack from[0xd4eaf000 - 0xd4f00000] reserved and committed 324KB for Thread Stack from [0xf687866e] Thread::record_stack_base_and_size()+0x1be [0xf68818bf] JavaThread::run()+0x2f [0xf67541f9] java_start(Thread*)+0x119 [0xf7606395] start_thread+0xd5//******************** æ³¨æ„è¿™é‡Œ[0xd5a00000 - 0xe5a00000] reserved 262144KB for Java Heap from//******************** æ³¨æ„è¿™é‡Œ. . .[0xe5e00000 - 0xf4e00000] reserved 245760KB for Code from[0xf737f000 - 0xf7400000] reserved 516KB for GC from[0xf745d000 - 0xf747d000] reserved 128KB for Unknown from[0xf7700000 - 0xf7751000] reserved and committed 324KB for Thread Stack from[0xf7762000 - 0xf776a000] reserved and committed 32KB for Internal from å…¶ä¸­æœ‰ä¸€è¡Œ 1[0xd5a00000 - 0xe5a00000] reserved 262144KB for Java Heap from æ‰€åœ¨çš„é‚£ä¸€è¡Œï¼Œè¡¨ç¤ºäº†javaçš„å †å†…å­˜ä»0xd5a00000å¼€å§‹è¾…åŠ©ä¸Šåœ¨linuxå½“ä¸­ï¼Œè¿›ç¨‹çš„å†…å­˜åˆ†å¸ƒå›¾ï¼Œæ¯ä¸€å—å†…å­˜æ˜¯å¦‚ä½•åˆ†é…çš„å°±ä¸€ç›®äº†ç„¶äº† ç”¨äºå¯¹æ¯”ï¼Œé™„ä¸Šï¼Œè™šæ‹Ÿå†…å­˜ç©ºé—´åˆ†å¸ƒå›¾ï¼Œ vmstatpidstat","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://kevingeek.github.io/tags/Java/"}]},{"title":"å¤šç‰ˆæœ¬jdkå¸è½½","slug":"å¤šç‰ˆæœ¬jdkå¸è½½","date":"2020-04-14T07:48:53.000Z","updated":"2020-04-17T15:03:51.987Z","comments":true,"path":"2020/04/14/å¤šç‰ˆæœ¬jdkå¸è½½/","link":"","permalink":"http://kevingeek.github.io/2020/04/14/%E5%A4%9A%E7%89%88%E6%9C%ACjdk%E5%8D%B8%E8%BD%BD/","excerpt":"ä¹‹å‰åœ¨æœºå™¨ä¸Šæœ‰è‡ªå·±å®‰è£…jdkï¼Œåé¢å› ä¸ºæ˜¯centosï¼Œå› ä¸ºå¼€å‘å·¥å…·åŒ…çš„å…³ç³»æ‰€ä»¥åˆå®‰è£…äº†open-jdkï¼Œå¯¼è‡´äº†æ˜¯è¯´åŒæ—¶å­˜åœ¨å¤šä¸ªç‰ˆæœ¬jdkçš„é—®é¢˜ï¼Œ","text":"ä¹‹å‰åœ¨æœºå™¨ä¸Šæœ‰è‡ªå·±å®‰è£…jdkï¼Œåé¢å› ä¸ºæ˜¯centosï¼Œå› ä¸ºå¼€å‘å·¥å…·åŒ…çš„å…³ç³»æ‰€ä»¥åˆå®‰è£…äº†open-jdkï¼Œå¯¼è‡´äº†æ˜¯è¯´åŒæ—¶å­˜åœ¨å¤šä¸ªç‰ˆæœ¬jdkçš„é—®é¢˜ï¼Œ åœ¨ä½¿ç”¨jmapçš„æ—¶å€™æŠ¥äº†å¦‚ä¸‹é”™è¯¯ï¼ˆä¿¡æ¯æ˜¯ç½‘ä¸ŠæŠ„çš„ï¼Œå¤§è‡´æ˜¯è¿™ä¸ªæ„æ€ï¼‰ Exception in thread \"main\" sun.jvm.hotspot.runtime.VMVersionMismatchException: Supported versions are 1.5.0, 1.5.0_xx. Target VM is 20.6-b01 æ‰€ä»¥éœ€è¦åˆ æ‰æœ¬æœºçš„open-sdkï¼Œç»Ÿä¸€æˆoracle-jdkï¼Œå¦‚æœjava -versionå‡ºç°ä»¥ä¸‹æç¤ºï¼Œè¯´æ˜é»˜è®¤ä½¿ç”¨çš„æ˜¯open-jdk java version \"1.8.0\" OpenJDK Runtime Environment (build 1.8.0-b09) OpenJDK 64-Bit Server VM (build 1.8.0-b09, mixed mode) æœ€å¥½è¿˜æ˜¯å…ˆå¸è½½æ‰openjdk,åœ¨å®‰è£…Oracleçš„jdk, ###1.ç¡®å®šJDKçš„ç‰ˆæœ¬ï¼šrpm -qa | grep jdk å¯èƒ½çš„ç»“æœæ˜¯ï¼š libgcj-4.1.2-42.el5java-1.4.2-gcj-compat-1.4.2.0-40jpp.115 ###2.ç„¶åå¸è½½ï¼š yum -y remove java-1.4.2-gcj-compat-1.4.2.0-40jpp.115 å¸è½½å®Œæˆä»¥åï¼Œå¯ä»¥ç”¨whereis javaæŸ¥çœ‹javaçš„è·¯å¾„ï¼Œ java: /opt/java/jdk1.8.0_141/bin/java /opt/java/jdk1.8.0_141/jre/bin/java è¿™æ—¶å€™å¦‚æœç›´æ¥ç”¨javaï¼Œå¯èƒ½ä¼šæŠ¥é”™è¯´ â€œ/usr/bin/java not foundâ€é€€å‡ºç»ˆç«¯ï¼Œå¹¶ä¸”é‡æ–°æ‰“å¼€ä¸€ä¸ªç»ˆç«¯å³å¯","categories":[],"tags":[{"name":"basic","slug":"basic","permalink":"http://kevingeek.github.io/tags/basic/"}]},{"title":"Difference Between Redis And Memcache","slug":"Difference-Between-Redis-And-Memcache","date":"2020-04-08T08:02:02.000Z","updated":"2020-04-17T12:34:39.363Z","comments":true,"path":"2020/04/08/Difference-Between-Redis-And-Memcache/","link":"","permalink":"http://kevingeek.github.io/2020/04/08/Difference-Between-Redis-And-Memcache/","excerpt":"è¿™é‡Œä¸»è¦ä»‹ç»ä¸€ä¸‹Rediså’ŒMemcacheçš„ä¸€äº›å¼‚åŒ","text":"è¿™é‡Œä¸»è¦ä»‹ç»ä¸€ä¸‹Rediså’ŒMemcacheçš„ä¸€äº›å¼‚åŒ Redis &amp; Memcacheï¼Œéƒ½æ˜¯åŸºäºå†…å­˜çš„å­˜å‚¨ç³»ç»Ÿï¼Œç²—ç•¥çš„è¯´ æ“ä½œä¸ŠRedisæ”¯æŒæœåŠ¡ç«¯çš„æ•°æ®æ“ä½œï¼Œï¼ˆæ¯”å¦‚incrï¼‰ï¼Œä½†æ˜¯Memcacheä¸è¡Œï¼Œéœ€è¦å°†å€¼ä»æœåŠ¡å™¨ä¸Šå–ä¸‹æ¥ï¼Œè¿ç®—ï¼Œä¹‹åå†å­˜å›Memcache å†…å­˜ä½¿ç”¨ç‡ä¸ŠMemcacheçš„å†…å­˜ä½¿ç”¨ç‡æ¯”Redisæ›´ä½ã€‚ï¼ˆå’Œå†…å­˜åˆ†é…ç­–ç•¥ï¼Œå’Œæ•°æ®ç»“æ„æœ‰å…³ï¼‰ cpuä½¿ç”¨ä¸ŠRedisä»…æ”¯æŒå•æ ¸cpuï¼Œä½†æ˜¯Memcacheæ”¯æŒå¤šæ ¸cpu å†è¯¦ç»†ç‚¹1. Redisä½¿ç”¨å¾ˆå¤šçš„è¿™ä¸ªæ•°æ®é›†åˆï¼Œæ¯”å¦‚ä¸‹å›¾ä¸­åˆ—çš„ string hash list set sorted set 2. å†…å­˜ç®¡ç†æœºåˆ¶æ€§èƒ½ï¼šåœ¨redisä¸­ï¼Œå…è®¸å­˜å‚¨çš„å†…å®¹ï¼Œæ¯”å®é™…çš„ç‰©ç†å†…å­˜è¦æ›´å¤§ï¼Œå½“ç‰©ç†å†…å­˜ç”¨å®Œä¹‹åï¼Œå°±ä¼šä½¿ç”¨swapåˆ†åŒºã€‚swapæ“ä½œæ˜æ˜¾ä¼šé€ æˆioé˜»å¡å…³äºVirtualMachineè€Œmemcacheä¸è¡Œï¼Œä»…æ”¯æŒç‰©ç†å†…å­˜æ“ä½œï¼Œæ‰€ä»¥ï¼Œä»çº¯é€Ÿåº¦ä¸Šæ¥è¯´ï¼Œmemcacheçš„æ€§èƒ½è¦æ¯”redisè¦æ›´å¥½ã€‚æœºåˆ¶:memcacheçš„å†…å­˜åˆ†å¸ƒå¦‚ä¸‹æ‰€ç¤ºï¼Œå…¶å®ç±»ä¼¼äºlinuxæ–‡ä»¶ç³»ç»Ÿï¼Œå­˜åœ¨ä¸€å®šçš„å†…å­˜æµªè´¹ è€Œå…³äºredisçš„å†…å­˜åˆ†é…åˆ™æ˜¯æ ¹æ®åŸºç¡€ç»“æ„æ¥å®šçš„ï¼Œæµªè´¹è¾ƒå°‘ï¼Œä¸è¿‡è¿™æ ·çš„åˆ†é…å®¹æ˜“å‡ºç°å†…å­˜ç¢ç‰‡é—®é¢˜ï¼Œå®˜æ–¹æ–‡æ¡£èµ„æºåˆ™è¯¦ç»†å¾—å¤šï¼Œæˆ‘è¿™é‡Œç›´æ¥ç²˜ä¸€ä¸‹å¥½äº†ï¼Œä¸€å…±4ç‚¹ å½“keyè¢«åˆ é™¤çš„æ—¶å€™ï¼Œredisä¸ä¼šç«‹åˆ»é‡Šæ”¾å†…å­˜ï¼Œå¦‚æœä½¿ç”¨äº†5Gå†…å­˜ï¼Œç„¶åé‡Šæ”¾äº†2Gï¼Œé‚£ä¹ˆå®é™…ä¸Šçš„å ç”¨ä¾ç„¶ä¼šæ˜¯5G åŸºäºç¬¬ä¸€ç‚¹ï¼Œéœ€è¦é¢„è§åˆ°å®é™…çš„rediså ç”¨ï¼Œå¦‚æœé«˜å³°æœŸå¯èƒ½ä½¿ç”¨åˆ°10Gï¼Œé‚£ä¹ˆå°±éœ€è¦æå‰é¢„å¤‡10Gçš„å†…å­˜ï¼ˆè²Œä¼¼æ˜¯åºŸè¯ï¼‰ å¦‚æœç”³è¯·äº†5Gä¹‹åï¼Œé‡Šæ”¾äº†2Gï¼Œä¹‹ååˆéœ€è¦ä½¿ç”¨å†…å­˜ï¼Œé‚£ä¹ˆredisä¼šåŸºæœ¬ä¸Šä¼šé‡å¤ä½¿ç”¨è¿™2Gçš„èµ„æºï¼ˆè²Œä¼¼ä¹Ÿæ˜¯åºŸè¯ï¼‰ è¿™æ ·çš„è¯ï¼Œç¢ç‰‡ç‡çš„å½“ å³°å€¼/å¹³æ—¶å€¼ æ¯”ç‡è¾ƒé«˜çš„æ—¶å€™ï¼Œç¢ç‰‡ç‡ä¼šæ¯”è¾ƒé«˜å‚è€ƒéƒ¨åˆ†ï¼šmemory-optimization 3. æ•°æ®æŒä¹…åŒ–memcacheç®€å•ç²—æš´ï¼Œç›´æ¥ä¸æ”¯æŒredisæ”¯æŒï¼Œä¸¤ç§æ¨¡å¼ï¼šrdbå¿«ç…§&amp;AOFæ–‡ä»¶ 4. é›†ç¾¤åŒ–ç®¡ç† memcacheæœ¬èº«å¯¹äºé›†ç¾¤åŒ–æ˜¯æ— æ„ŸçŸ¥çš„ï¼Œå°±æ˜¯è¯´ï¼Œå¯ä»¥å¯åŠ¨å¤šä¸ªmemcacheèŠ‚ç‚¹ï¼Œå®Œäº†åœ¨å®¢æˆ·ç«¯é€šè¿‡ç®—æ³•ï¼Œå°†æ•°æ®hashåˆ°å„ä¸ªèŠ‚ç‚¹ä¸Šï¼Œé€šè¿‡clientç«¯çš„å¤„ç†æ¥åšä¸€ä¸ªé›†ç¾¤ redisçš„é›†ç¾¤åˆ™å¯ä»¥ç›´æ¥åœ¨æœåŠ¡ç«¯åšå¤„ç†","categories":[{"name":"tech","slug":"tech","permalink":"http://kevingeek.github.io/categories/tech/"}],"tags":[{"name":"In-Memory Data Storage Systems","slug":"In-Memory-Data-Storage-Systems","permalink":"http://kevingeek.github.io/tags/In-Memory-Data-Storage-Systems/"}]},{"title":"2019, New Beginning","slug":"hello-world","date":"2019-01-01T08:02:02.000Z","updated":"2020-04-17T16:22:32.940Z","comments":true,"path":"2019/01/01/hello-world/","link":"","permalink":"http://kevingeek.github.io/2019/01/01/hello-world/","excerpt":"æ²¡å•¥å¥½è¯´çš„ï¼Œç»™æ‚¨åŠˆä¸ªå‰å§","text":"æ²¡å•¥å¥½è¯´çš„ï¼Œç»™æ‚¨åŠˆä¸ªå‰å§","categories":[{"name":"normal","slug":"normal","permalink":"http://kevingeek.github.io/categories/normal/"}],"tags":[]},{"title":"è‹¦å‘½ç®¡å®¶ä¹‹å·§è§£è‰è“é£æ³¢","slug":"Stawberry","date":"2017-02-19T10:24:50.000Z","updated":"2020-04-17T15:03:39.002Z","comments":true,"path":"2017/02/19/Stawberry/","link":"","permalink":"http://kevingeek.github.io/2017/02/19/Stawberry/","excerpt":"é˜¿å“²æ˜¯æ‘ä¸œè¾¹çš„å¤§æˆ·ï¼Œä»–æœ‰ä¸€ä¸ªç‰¹åˆ«å‰å®³çš„ç®¡å®¶ï¼Œèƒ½è¯´ä¼šé“ï¼Œæ™ºå•†è¶…äººï¼Œè¯´åˆ°è‰è“é£æ³¢â€¦","text":"é˜¿å“²æ˜¯æ‘ä¸œè¾¹çš„å¤§æˆ·ï¼Œä»–æœ‰ä¸€ä¸ªç‰¹åˆ«å‰å®³çš„ç®¡å®¶ï¼Œèƒ½è¯´ä¼šé“ï¼Œæ™ºå•†è¶…äººï¼Œè¯´åˆ°è‰è“é£æ³¢â€¦ äº‹èµ·è€çˆ·å¹³æ—¥æ²¡å•¥çˆ±å¥½ï¼Œå¹´å‰ä¸‹è‹æ­æ—¶å€™ç¢°å·§å°äº†ä¸€æ¬¡è‰è“ï¼Œè‡³æ­¤æ¯æ—¥å¿µå¿µä¸å¿˜ï¼Œæ‹›æ¥ç®¡å®¶â€¦ åŸæ¥æ˜¯è€çˆ·å˜´é¦‹äº† å˜´é¦‹ä¹Ÿæœ‰è®²ç©¶ï¼Œä¸æ˜¯èƒ¡åƒæµ·å–ï¼Œå’±ä»¬è¦æŒç»­æ€§å‘å±•â€¦ è‰è“è¿™ç‰©ä»¶ï¼Œè¿™å¹´ä»£ä¹Ÿæ²¡å†°ç®±ä»€ä¹ˆçš„ï¼Œæœ€æ–°é²œçš„å°±æ˜¯æ¯æ—¥é‡‡æ‘˜ï¼Œè€çˆ·åšçš„é•¿è¿œæ‰“ç®—ï¼Œæ¯æ—¥ä¸€é†’å°±å¯¹è‰è“å¿ƒå¿ƒå¿µå¿µï¼Œæ‰€ä»¥å•Šï¼Œå°±æƒ³è¶Šæ—©è¶Šå¥½ï¼Œæ™šæ¥ä¸€ç‚¹ä¹Ÿæ²¡å…³ç³»ï¼Œä½†æ˜¯å¿…é¡»æ˜¯ä»Šå¤©æ‘˜çš„æ‰è¡Œï¼Œä½†æ˜¯ä¸€å¤©éƒ½æ²¡åƒåˆ°å¥½è‰è“ï¼Œæˆ‘å¯æ˜¯è¦å‘é£™å“¦ï¼ è¿˜æœ‰ï¼Œè¿™è‰è“è™½å¥½ï¼Œä½†æ˜¯ä¹Ÿä¸èƒ½è´ªæ¯å“¦â€¦å•Šå‘¸ï¼Œä¸èƒ½å¤šåƒï¼Œæ¯æ—¥ä¸€è¢‹æ˜¯ä¸ºæœ€å¥½ï¼Œä¹‹åæ¥çš„ï¼Œå°±æŠŠä»–ä»¬é€€æ‰å§ï¼ è€çˆ·æƒ³è¦çš„æ˜¯ä»€ä¹ˆå¯¹äºè€çˆ·çš„æƒ³æ³•ï¼Œç®¡å®¶è‡ªç„¶æ˜¯æ‘¸å¾—é€å½»ï¼Œç¨ä½œç›˜ç®—ï¼Œå°±çŸ¥é“è€çˆ·æƒ³çš„æ˜¯å•¥ æ¯å¤©éƒ½éœ€è¦æ¶ˆè€—ä¸€æ‰¹è‰è“(å°½æœ€å¤§åŠªåŠ›) æ¯å¤©ä»…åƒä¸€æ‰¹è‰è“ åªåƒå½“æ—¥æœ€æ–°é²œçš„ã€è´¨é‡è¿‡å…³çš„è‰è“ï¼Œè‡³äºæ˜¯è°æä¾›çš„å¹¶ä¸é‡è¦ å¦‚æœæœ‰å¤šä½™çš„æˆ–è€…ä¸åˆæ ¼çš„è‰è“ï¼Œåˆ™éœ€è¦æŠŠä»–ä»¬å¤„ç†æ‰(é€€è´§) å¬é›†å•†å®¶ä»»åŠ¡å©å’ä¸‹å»ï¼Œè®©ç®¡å®¶ä¸€æ‰‹æ“åŠï¼Œè€æ¿æå‡ºäº†éœ€æ±‚ï¼Œé‚£ç®¡å®¶å°±åªèƒ½è·‘è·‘è…¿äº†ï½ è¦æ‹¿åˆ°è‰è“ï¼Œé‚£å¾—é¦–å…ˆè”ç³»ä¸€ä¸‹è‰è“ä¾›åº”å•†æ˜¯ä¸ªä»€ä¹ˆæƒ…å†µ å‡ æ—¥ä¹‹åï¼Œå¾ˆå¿«å°±æœ‰äº†æ¶ˆæ¯ï¼Œè¿™å‡ å®¶ä¾›åº”å•†ï¼Œå› ä¸ºè‰è“å±äºç°æ‘˜ï¼Œæ¯æ—¥çš„æƒ…å†µéƒ½ä¸ä¸€æ ·ï¼Œä¾›åº”å•†æ¯å¤©é€æ¥éƒ½è´§ç‰©è´¨é‡ä¹Ÿéƒ½å‚å·®ä¸é½ï¼Œéœ€è¦ç®¡å®¶ä¸€ä¸€éªŒè¿‡å¦‚æœè´§ç‰©è´¨é‡ä¸è¡Œï¼Œé‚£ä¹ˆå°±åªèƒ½é€€è´§å•¦ï¼Œåˆæˆ–è€…æˆ‘ä»¬è€çˆ·å½“æ—¥åªèƒ½åƒè¿‡è‰è“äº†ï¼Œé‚£ä¹ˆæŠ±æ­‰ï¼Œä½ è¿™æ‰¹è´§æˆ‘åªèƒ½é€€å•¦ï¼Œè¦æ˜¯ä½ æ¥çš„æ—¶å€™ï¼Œç®¡å®¶è¿˜åœ¨éªŒä¸Šå®¶çš„è´§ï¼Œé‚£ä½ å¯ä»¥ç¢°ç¢°è¿æ°”ï¼Œä¸‡ä¸€ä¸Šå®¶çš„è´§ç‰©ä¸è¿‡å…³å‘¢ï¼Œæ˜¯å§ï½ ç®€è€Œè¨€ä¹‹ï¼Œå¸‚åœºç«äº‰çœŸæ˜¯æ¿€çƒˆå‘€ï¼ é‚£ä¹ˆæç‚¼ä¸€ä¸‹ï¼š ä¸ä¿è¯æ¯æ—¥éƒ½æœ‰è´§ç‰© ä¸ä¿è¯è´§ç‰©çš„è´¨é‡ ä¸ä¿è¯åˆ°è´§æ—¶é—´ æ¥å—é€€è´§ ä¾›åº”å•†åœ¨è´§ç‰©é€åˆ°ä¹‹å‰ï¼Œå¹¶ä¸çŸ¥æ™“è€çˆ·ä»Šæ—¥æ˜¯å¦å·²ç»äº«ç”¨äº†è‰è“ å—¯ï¼Œä»»æ€§çš„ä¾›åº”å•†æä¾›çš„æœåŠ¡è¿˜çœŸæ˜¯ä¸æ€ä¹ˆå¯é å•Šï¼Œä½†æ˜¯è¿™æ€»éš¾ä¸ä½èªæ˜çš„ç®¡å®¶ï¼Œå’‹ä¸€çœ‹ï¼Œè™½ç„¶æ¯ä¸€å®¶è´§ç‰©æä¾›å•†å¹¶ä¸èƒ½æä¾›å®Œå…¨å¯é çš„æœåŠ¡ï¼Œä½†æ˜¯æˆ‘å¤šå–Šå‡ å®¶ä¸€èµ·ä¸Šï¼Œé‚£ä¹ˆè€çˆ·çš„éœ€æ±‚è¿˜æ˜¯å¯ä»¥å°½é‡æ»¡è¶³çš„å˜›ï¼Œæƒ³åˆ°è¿™é‡Œï¼Œç®¡å®¶å°±è¢«è‡ªå·±çš„èªæ˜æ‰æ™ºé”æŠ˜æœäº†ï¼Œå¿ƒé‡Œè¿˜æœ‰ç‚¹å°æ¿€åŠ¨å‘¢ (à²¡Ï‰à²¡)hiahiahia å¿ƒä¸­ä¸€é˜µç›˜ç®—ä¹‹åï¼Œé€šçŸ¥ä¾›åº”å•†ä»¬å¬é›†åˆ°é™¢ä¸­å¼€äº†ä¸€æ¬¡é›†ä½“ä¼šè®®â€¦. ä¸€ä¸ªæœˆé»‘é£é«˜çš„å¤œæ™šä¼—å•†å®¶ï¼Œä»Šæ—¥å°†å¤§å®¶å¬é›†åˆ°æ­¤ï¼Œæ˜¯ä¸ºäº†é€šçŸ¥å„å•†å®¶ä¹‹åå’±ä»¬çš„ç»Ÿä¸€ä¾›è´§æ–¹å¼ï¼Œä¸€æ–¹é¢å°½é‡ä¿è¯è€çˆ·çš„è¦æ±‚ï¼Œä¸€æ–¹é¢å‘¢ï¼Œä¹Ÿæ˜¯å’Œå¤§å®¶æ‰“ä¸ªæ‹›å‘¼ï¼Œå’±ä»¬ä»¥åå°±æŒ‰ç…§è¿™ä¸ªæ³•å­æ¥ï¼Œäº’é€šæœ‰æ— å˜› ä¹‹åæ¯æ—¥ï¼Œè‹¥å„ä½è´§ç‰©åˆ°åï¼Œå¯å°†è´§ç‰©å…ˆç½®æ”¾äºé™¢ä¸­ï¼Œç„¶åç”±çŸ¥æ™“æˆ‘ï¼Œå¾…æˆ‘æ¥å¯¹è´§ç‰©è¿›è¡ŒéªŒæ”¶ï¼ŒéªŒæ”¶é€šè¿‡ä¹‹åï¼Œå‘ä½ å‘æ”¾å½“æ—¥æ¬¾é¡¹ã€‚è‹¥é€šçŸ¥æˆ‘æ—¶ï¼Œæˆ‘å·²æ‰¾åˆ°ä¸€æ‰¹æ–°é²œçš„è´§ç‰©ï¼Œé‚£ä¹ˆä½ è´§çš„æ–°é²œç¨‹åº¦ä¸å¦‚ä¸Šå®¶ï¼Œè‡ªç„¶æ˜¯è¾“äº†ï¼Œé‚£ä¹ˆæˆ‘å°±æ— æ³•ç»™ä½ æ¬¾é¡¹ï¼Œåªèƒ½å°†è´§é€€è¿˜ç»™ä½ ã€‚è‹¥æˆ‘è¿˜åœ¨éªŒè´§ï¼Œé‚£ä½ å¯ä»¥å†ç­‰ç­‰ï¼Œè‹¥ä¹‹å‰çš„è´§ç‰©ä¸åˆæ ¼ï¼Œé‚£ä¹ˆä½ å¯ä»¥ç­‰ç­‰ï¼Œè‹¥ä¸Šå®¶çš„è´§ç‰©ä¸ç¬¦åˆè€çˆ·çš„è¦æ±‚ï¼Œé‚£ä¹ˆæˆ‘å°±å¯ä»¥æ¥éªŒä½ çš„è´§å•¦ï½ å„å•†å®¶è§ç®¡å®¶æå‡ºå¦‚æ­¤å¦¥å–„çš„æ³¨æ„ï¼Œäº‹å°‘ï¼Œä¹Ÿä¸ç”¨å’Œåˆ«å®¶ä¼¤å’Œæ°”ï¼Œä¸€åˆ‡ä¹°å–å…¨å‡­æœ¬äº‹ï¼Œä¸€ä¸ªä¸€ä¸ªä¹Ÿæ‘©æ‹³æ“¦æŒï¼Œçº·çº·è¡¨ç¤ºèµåŒ å•æœºç‰ˆä¸€æ®µæ—¶æ—¥ä¹‹åï¼Œè€çˆ·å¦‚æ„¿åƒä¸Šäº†æƒ³è¦çš„è‰è“ğŸ“ï¼Œç®¡å®¶ä¹Ÿå°†æ­¤æ–¹æ³•è®°å½•äº†ä¸‹æ¥ï¼Œä»¥ä¾¿æ”¹è¿›ä¸å­¦ä¹  :) å•†å®¶p1ã€p2å±äºé›†åˆP(Provider)ï¼Œå•†å®¶æä¾›çš„æœåŠ¡éƒ½æ˜¯åŒè´¨çš„ï¼Œå¯ä»¥å½’ä¸ºä¸€ç±»ï¼Œåˆ†åˆ«ä¸º é€è´§ deliver éªŒè´§ validate é€€è´§ takeBack è€Œç®¡å®¶g(governor)çš„çŠ¶æ€åˆ†ä¸ºå‡ ç§ å°šæœªéªŒè´§ available æ­£åœ¨éªŒè´§ validating éªŒè´§ç»“æŸ unavailable é‚£ä¹ˆå•†å®¶æ‰€æ‰§è¡Œçš„æ­¥éª¤å¯ä»¥ç”¨å¦‚ä¸‹ä¼ªä»£ç è¡¨ç¤ºï¼š 123456789101112131415161718192021public class ProviderDeliver &#123; public void dailyWork(Provider p, Governor g)&#123;&#125; p.deliver(); if (g.unavailable()) &#123; p.takeBack(); return ; &#125; while (g.validating()) &#123; // simply wait &#125; if (g.available()) &#123; p.validate(); &#125; else &#123; p.takeBack(); &#125;&#125; åˆ†å¸ƒå¼ç‰ˆå“å‘€ï¼Œè€çˆ·ä¸€é«˜å…´ï¼Œèµé‡‘ç»™å¾—ç‰¹åˆ«é«˜ï¼Œå„è·¯å•†å®¶æ¥è¸µè€Œè‡³ï¼Œç®¡å®¶è¦å¿™ä¸è¿‡æ¥äº†ï¼Œäºæ˜¯å©å’ä¸‹å»å‡ ä¸ªå®¶ä¸ï¼Œåˆ†åˆ«æ¥å¾…å•†æˆ·ï¼Œæ£€æŸ¥ä¾ç„¶ç”±ç®¡å®¶äº²è‡ªæ“ä½œï¼Œä½†å•†æˆ·æ— éœ€ç­‰å¾…ï¼Œä»…éœ€è¦å°†è´§ç‰©æ”¾åœ¨åºœä¸­ï¼Œé€€è´§ç”±å®¶ä¸å®Œæˆï¼Œè€Œå•†æˆ·ä¹Ÿä¸ç›´æ¥ä¸ç®¡å®¶æ¥è§¦ï¼Œç”±å®¶ä¸è´Ÿè´£å•†å®¶å’Œç®¡å®¶ä¹‹é—´çš„æ²Ÿé€šï¼Œç®¡å®¶é€šè¿‡åºœé‚¸ä¸­çš„æ——å¸œè¡¨ç¤ºè‡ªå·±ç›®å‰æ­£åœ¨éªŒè´§ã€ä¼‘æ¯ã€éªŒè´§å®Œæ¯• é‚£ä¹ˆæ•´ä½“çš„æµç¨‹ä½œä¸€ä¸‹ç®€å•è½¬æ¢ï¼Œå¯¹å•†æˆ·æ¥è¯´ï¼Œæµç¨‹æ›´åŠ ç®€å• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193/** * * Created by kevin on 20/02/2017. */public class Strawberry &#123; static AtomicInteger errorCount = new AtomicInteger(0); static AtomicInteger takeBackCount = new AtomicInteger(0); static AtomicInteger consumedCount = new AtomicInteger(0); static AtomicInteger acceptedCount = new AtomicInteger(0); static Random r = new Random(); static class ProviderDeliver2 &#123; private Provider p; ProviderDeliver2(String name) &#123; this.p = new Provider(name); &#125; void dailyWork(int day) &#123; Merchandise m = p.deliver(); // è¿é€è´§ç‰© Worker worker = Worker.of(this, day); // éšä¾¿æ‰¾ä¸ªå®¶ä¸ï¼Œå¹¶æŠŠè´§ç‰©äº¤ç»™ä»– worker.process(m); // å®¶ä¸æ¥å¤„ç†è´§ç‰© &#125; void takeBack(Merchandise m) &#123; int res = m.getTime().incrementAndGet(); if (res == 1) &#123; takeBackCount.incrementAndGet(); &#125; else if (res &gt; 1) &#123; System.out.println(\"fail! operate \" + res ); errorCount.incrementAndGet(); &#125; &#125; &#125; static class Worker &#123; private Governor g; private ProviderDeliver2 pd2; Worker(ProviderDeliver2 pd2, Governor g) &#123; this.pd2 = pd2; this.g = g; &#125; static Worker of(ProviderDeliver2 pd2, int day) &#123; return new Worker(pd2, Governor.getInstance(day)); &#125; void process(Merchandise m) &#123; g.validate(this, m); &#125; void takeBack(Merchandise m) &#123; pd2.takeBack(m); &#125; &#125; static class Governor &#123; private AtomicBoolean available = new AtomicBoolean(true); private AtomicBoolean validating = new AtomicBoolean(false); private Queue&lt;Merchandise&gt; queue = Queues.newConcurrentLinkedQueue(); private int date; private static ConcurrentHashMap&lt;Integer, Governor&gt; MAP = new ConcurrentHashMap&lt;&gt;(); static Governor getInstance(int day) &#123; return MAP.computeIfAbsent(day, Governor::new); &#125; boolean available() &#123; return available.get(); &#125; private Governor(int date) &#123; this.date = date; &#125; void validate(Worker worker, Merchandise m) &#123; try &#123; if (!available()) &#123; worker.takeBack(m); return; &#125; this.addMerchandise(m); if (!validating.compareAndSet(false, true)) &#123; return; &#125; if (!available()) &#123; cleanAll(worker); return; &#125; while (!queue.isEmpty()) &#123; Merchandise item = queue.poll(); if (available() &amp;&amp; item.isGood()) &#123; available.set(false); acceptedCount.incrementAndGet(); &#125; else &#123; worker.takeBack(item); &#125; &#125; validating.set(false); &#125; finally &#123; consumedCount.incrementAndGet(); &#125; &#125; private void cleanAll(Worker worker) &#123; while (!queue.isEmpty()) &#123; Merchandise item = queue.poll(); worker.takeBack(item); &#125; &#125; void addMerchandise(Merchandise m) &#123; queue.add(m); &#125; &#125; public static class Provider &#123; private String name; Provider(String name) &#123; this.name = name; &#125; Merchandise deliver() &#123; return new Merchandise(this.name + System.nanoTime()); &#125; &#125; static class Merchandise &#123; private String name; private AtomicInteger time = new AtomicInteger(0); private long quality = r.nextInt(100); AtomicInteger getTime() &#123; return time; &#125; Merchandise(String name) &#123; this.name = name; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Merchandise that = (Merchandise) o; return name != null ? name.equals(that.name) : that.name == null; &#125; @Override public int hashCode() &#123; return name != null ? name.hashCode() : 0; &#125; boolean isGood() &#123;// return true; return quality &lt; 80; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // æ¨¡ä»¿5ä¸ªå•†å®¶ï¼Œè¿ç»­æä¾›500æ—¥çš„æƒ…å†µ int k = 0; for (int day = 0; day &lt; 500; day++) &#123; int tmpDay = day; for (int i = 0; i &lt; 5; i++) &#123; new Thread(() -&gt; new ProviderDeliver2(String.valueOf(tmpDay)).dailyWork(tmpDay)).start(); k++; &#125; &#125; while (k != consumedCount.get()) &#123; Thread.sleep(10); &#125; System.out.println(\"done\"); System.out.println(errorCount.get()); //0 System.out.println(takeBackCount.get()); // System.out.println(acceptedCount.get()); // System.out.println(consumedCount.get()); // &#125;&#125;","categories":[{"name":"normal","slug":"normal","permalink":"http://kevingeek.github.io/categories/normal/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kevingeek.github.io/tags/Algorithm/"},{"name":"åˆ†å¸ƒå¼","slug":"åˆ†å¸ƒå¼","permalink":"http://kevingeek.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"é™æµä¹‹RateLimiter","slug":"RateLimiter","date":"2016-10-24T12:59:25.000Z","updated":"2020-04-09T04:19:33.057Z","comments":true,"path":"2016/10/24/RateLimiter/","link":"","permalink":"http://kevingeek.github.io/2016/10/24/RateLimiter/","excerpt":"é«˜å¹¶å‘ä¸‰æ¿æ–§,ç¼“å­˜ã€é™çº§å’Œé™æµ","text":"é«˜å¹¶å‘ä¸‰æ¿æ–§,ç¼“å­˜ã€é™çº§å’Œé™æµ è€è¯è¯´å¾—å¥½ï¼Œè¦æƒ³æœåŠ¡å™¨è€å¾—å¥½ï¼Œä¸‰æ¿æ–§ä¸èƒ½å°‘ï¼Œä»Šå¤©æˆ‘ä»¬å°±æ¥çœ‹çœ‹å…¶ä¸­çš„ä¸€æ¿æ–§â€“â€˜é™æµâ€™ ä»€ä¹ˆæ˜¯é™æµ ç®€å•æ˜äº†çš„è¯´ï¼Œåœ¨ç³»ç»Ÿå½“ä¸­ï¼Œæœ‰ä¸€äº›ç¬¬ä¸‰æ–¹åº”ç”¨å…·æœ‰å¹¶è¡Œèƒ½åŠ›ä¸Šé™(æ¯”å¦‚æŸäº›å„æ–­è¡Œä¸šæä¾›çš„æ¥å£)ï¼Œä½ å¤šè¯·æ±‚äº†ç›´æ¥ç»™ä½ è¿”å›é”™è¯¯ç ï¼Œè¿˜æœ‰ä¸€äº›å…·ä½“çš„æœåŠ¡ï¼Œæ¯”å¦‚ç§’æ€ç­‰ï¼Œä»…å…è®¸ä¸€å®šçš„é€Ÿç‡æ¥è®¿é—®ç‰¹å®šçš„èµ„æºï¼Œåœ¨è¿™äº›åº”ç”¨åœºæ™¯ä¸­ï¼Œå°±éœ€è¦ç”¨åˆ°é™æµæ¥å®Œæˆè¿™äº›äº‹æƒ…ã€‚ ä¸€äº›é€šå¸¸çš„caseï¼Œæ¯”å¦‚è¯´é™åˆ¶æ€»å¹¶å‘æ•°(DB)ï¼Œç¬é—´å¹¶å‘æ•°(Nginx limit_conn)ï¼Œé™åˆ¶å¹³å‡é€Ÿç‡(RateLimiter)ç­‰ã€‚è€Œæˆ‘ä»¬ä»Šå¤©æ‰€è¦å…·ä½“è®¨è®ºçš„ï¼Œå°±æ˜¯é™åˆ¶å¹³å‡é€Ÿç‡çš„æ–¹æ³•ã€‚ ä¸¤å¤§ç®—æ³• å½“ç„¶ï¼Œåœ¨æ­¤ä¹‹å‰æˆ‘ä»¬å…ˆæ¥è®¨è®ºä¸€ä¸‹é™æµçš„ä¸¤å¤§ç®—æ³•ï¼šæ¼æ¡¶ã€ä»¤ç‰Œæ¡¶ã€‚ æ¼æ¡¶ ä»¤ç‰Œæ¡¶ ReteLimiterå¥½å•¦,é‚£å°±è®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ä»¤ç‰Œæ¡¶ç®—æ³•çš„å…·ä½“åº”ç”¨,å¼ºå¤§çš„guavaåŒ…çš„RateLimiterå·²ç»å®ç°äº†é™æµ,ä½¿ç”¨çš„æ˜¯ä»¤ç‰Œæ¡¶ç®—æ³•,å¹¶ä¸”å¯ä»¥å…è®¸ä¸€å®šç¨‹åº¦çš„è¯·æ±‚æ¿€å¢,çœ‹èµ·æ¥æ˜¯éå¸¸å¥½çš„ä¸œè¥¿ç®€å•æ¥è¯´,çœ‹æ³¨é‡Šä¸Šæ¥è¯´,æ˜¯é€šè¿‡æ—¶é—´çš„æ¢ç®—æ¥ç­‰ä»·äºä»¤ç‰Œçš„å­˜å‚¨çš„,å…·ä½“çš„å®ç°æ–¹æ³•,çœ‹å…·ä½“çš„ä»£ç å®ç°å§ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774/* * Copyright (C) 2012 The Guava Authors * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at å±Œå±Œçš„ï¼Œå…ˆè¯´æ˜ä¸€ä¸‹æ˜¯åŸºäºApache2çš„å“¦ï½ * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.common.util.concurrent;import com.google.common.annotations.Beta;import com.google.common.annotations.VisibleForTesting;import com.google.common.base.Preconditions;import com.google.common.base.Ticker;import java.util.concurrent.TimeUnit;import javax.annotation.concurrent.ThreadSafe;/** * A rate limiter. Conceptually, a rate limiter distributes permits at a * configurable rate. Each &#123;@link #acquire()&#125; blocks if necessary until a permit is * available, and then takes it. Once acquired, permits need not be released. å­—é¢æ„æ€ä¸Šæ¥è¯´ï¼ŒrateLimiterå½“ç„¶æ˜¯æŒ‰ç…§ä¸€ä¸ªç»™å®šçš„é€Ÿç‡æ¥è¿›è¡Œæ´¾å‘ä»¤ç‰Œå•¦ï½ æ‰§è¡Œacquire()æ–¹æ³•ï¼Œä¼šä¸€ç›´é˜»å¡ï¼Œç›´åˆ°æœ‰ä¸€ä¸ªä»¤ç‰Œæ˜¯å¯ç”¨çš„ï¼Œç„¶åè·å¾—è¿™ä¸ªä»¤ç‰Œï¼Œä¸€æ—¦ä»¤ç‰Œè¢«è·å¾—! ä»¤ç‰Œæ˜¯ä¸éœ€è¦è¢« `é‡Šæ”¾` çš„! * &lt;p&gt;Rate limiters are often used to restrict the rate at which some * physical or logical resource is accessed. This is in contrast to &#123;@link * java.util.concurrent.Semaphore&#125; which restricts the number of concurrent * accesses instead of the rate (note though that concurrency and rate are closely related, * e.g. see &lt;a href=\"http://en.wikipedia.org/wiki/Little's_law\"&gt;Little's Law&lt;/a&gt;). RateLimiter å¸¸å¸¸è¢«ç”¨æ¥é™åˆ¶æŸäº›èµ„æºçš„è®¿é—®é€Ÿç‡ã€‚ è¿™å’ŒSemaphoreä¸åŒï¼ŒSemaphoreæ˜¯ç”¨æ¥é™åˆ¶ å¹¶å‘æ•°è€Œä¸æ˜¯é€Ÿç‡ï¼Œè¿™ä¸¤è€…è¿˜æ˜¯æœ‰ä¸åŒçš„ã€‚ * &lt;p&gt;A &#123;@code RateLimiter&#125; is defined primarily by the rate at which permits * are issued. Absent additional configuration, permits will be distributed at a * fixed rate, defined in terms of permits per second. Permits will be distributed * smoothly, with the delay between individual permits being adjusted to ensure * that the configured rate is maintained. å¦‚æœæ²¡æœ‰é¢å¤–çš„é…ç½®ï¼Œä»¤ç‰Œä¼šä»¥å›ºå®šçš„é€Ÿç‡æ´¾å‘ï¼Œè¿™ä¸ªé€Ÿç‡ä»¥æ¯ç§’ä¸ºå•ä½è®¡ç®—ã€‚ ä»¤ç‰Œå°†ä¼šä»¥å¹³æ»‘çš„é€Ÿç‡æ´¾å‘ï¼Œå•ä½ä»¤ç‰Œä¹‹é—´çš„é—´éš”ä¼šè¢«è‰¯å¥½è°ƒé…ä»¥ä¿éšœä¹‹å‰è®¾å®šå¥½çš„é€Ÿç‡ã€‚ * * &lt;p&gt;It is possible to configure a &#123;@code RateLimiter&#125; to have a warmup * period during which time the permits issued each second steadily increases until * it hits the stable rate. é€šè¿‡é…ç½®ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ä¸€ä¸ªé¢„çƒ­çš„é˜¶æ®µï¼Œåœ¨è¿™ä¸ªé˜¶æ®µä¸­æ¯ç§’åˆ†å‘çš„ä»¤ç‰Œæ•°å°†ä¼šé€’å¢ç›´åˆ°è¾¾åˆ°è¾¹ç•Œå€¼ä¸ºæ­¢ * * &lt;p&gt;As an example, imagine that we have a list of tasks to execute, but we don't want to * submit more than 2 per second: ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œæœ‰ä¸€ä¸ªä»»åŠ¡é˜Ÿåˆ—éœ€è¦æ‰§è¡Œï¼Œä½†æ˜¯æˆ‘ä»¬ä¸æƒ³æ¯ç§’åŒæ—¶æ‰§è¡Œçš„ä»»åŠ¡è¶…è¿‡2ä¸ªï¼Œé‚£ä¹ˆå¯ä»¥è¿™æ ·å†™ *&lt;pre&gt; &#123;@code * final RateLimiter rateLimiter = RateLimiter.create(2.0); // rate is \"2 permits per second\" * void submitTasks(List&lt;Runnable&gt; tasks, Executor executor) &#123; * for (Runnable task : tasks) &#123; * rateLimiter.acquire(); // may wait * executor.execute(task); * &#125; * &#125; *&#125;&lt;/pre&gt; * * &lt;p&gt;As another example, imagine that we produce a stream of data, and we want to cap it * at 5kb per second. This could be accomplished by requiring a permit per byte, and specifying * a rate of 5000 permits per second: å¦ä¸€ä¸ªä¾‹å­å°±æ˜¯ï¼Œæƒ³è±¡ä¸€ä¸‹æ­£åœ¨å¤„ç†ä¸€ä¸ªæ•°æ®æµï¼Œç„¶åæˆ‘ä»¬æƒ³æ¯ç§’å¤„ç†5kbã€‚è¿™é‡Œçš„å¤„ç†æ–¹å¼ï¼Œä¸ºæ¯ä¸ªbyteåˆ†é…ä¸€ä¸ªä»¤ç‰Œï¼Œ å¹¶ä¸”æŒ‡å®šæ¯ç§’æœ‰5000ä¸ªä»¤ç‰Œã€‚ *&lt;pre&gt; &#123;@code * final RateLimiter rateLimiter = RateLimiter.create(5000.0); // rate = 5000 permits per second * void submitPacket(byte[] packet) &#123; * rateLimiter.acquire(packet.length); * networkService.send(packet); * &#125; *&#125;&lt;/pre&gt; * * &lt;p&gt;It is important to note that the number of permits requested &lt;i&gt;never&lt;/i&gt; * affect the throttling of the request itself (an invocation to &#123;@code acquire(1)&#125; * and an invocation to &#123;@code acquire(1000)&#125; will result in exactly the same throttling, if any), * but it affects the throttling of the &lt;i&gt;next&lt;/i&gt; request. I.e., if an expensive task * arrives at an idle RateLimiter, it will be granted immediately, but it is the &lt;i&gt;next&lt;/i&gt; * request that will experience extra throttling, thus paying for the cost of the expensive * task. ä½œè€…æåˆ°äº†å¾ˆé‡è¦çš„ä¸€ç‚¹ï¼Œå½“å‰è¯·æ±‚çš„ä»¤ç‰Œæ•°é‡å¹¶ä¸ä¼šé˜»æ­¢å½“å‰çš„è¯·æ±‚ï¼Œacquire(1)å’Œacquire(1000)ä¼šå¯¼è‡´ç›¸åŒçš„ç»“æœï¼Œ å¦‚æœå½“å‰çš„è¯·æ±‚æ¶ˆè€—äº†ç‰¹åˆ«å¤šçš„ä»¤ç‰Œï¼Œé‚£ä¹ˆæ˜¯ç”±â€œä¸‹ä¸€ä¸ªè¯·æ±‚\"æ¥å¿è¿˜å½“å‰è¿™ä¸ªè¯·æ±‚æ‰€è€—è´¹çš„ä»¤ç‰Œã€‚ è¿™é‡Œæœ‰ç‚¹ç»•ï¼Œå…·ä½“è¿˜æ˜¯çœ‹ä»£ç å§ * * &lt;p&gt;Note: &#123;@code RateLimiter&#125; does not provide fairness guarantees. å—¯...è¿™å°±æ˜¯ä¸å…¬å¹³çš„ï¼Œå°±åƒè¿™ä¸ªä¸–ç•Œä¸€æ · =ã€‚= face and embrace it * * @author Dimitris Andreou * @since 13.0 */// TODO(user): switch to nano precision. A natural unit of cost is \"bytes\", and a micro precision// would mean a maximum rate of \"1MB/s\", which might be small in some cases.@ThreadSafe@Beta// wowï¼Œ åŸæ¥è¿™ç©æ„è¿˜åªæ˜¯ä¸ªBetaç‰ˆæœ¬å‘€ï½public abstract class RateLimiter &#123; /* * How is the RateLimiter designed, and why? * * The primary feature of a RateLimiter is its \"stable rate\", the maximum rate that * is should allow at normal conditions. This is enforced by \"throttling\" incoming * requests as needed, i.e. compute, for an incoming request, the appropriate throttle time, * and make the calling thread wait as much. å¯¹äºRateLimiteræœ€ä¸»è¦çš„ç‰¹æ€§å°±æ˜¯â€œç¨³å®šçš„é€Ÿç‡â€ï¼Œåœ¨é€šå¸¸æƒ…å†µä¸‹ï¼Œå…è®¸ä»¥æœ€é«˜çš„é€Ÿç‡è¿›è¡Œè¿ä½œã€‚ åé¢çš„ä¸çŸ¥é“æ€ä¹ˆç¿»è¯‘ * * The simplest way to maintain a rate of QPS is to keep the timestamp of the last * granted request, and ensure that (1/QPS) seconds have elapsed since then. For example, * for a rate of QPS=5 (5 tokens per second), if we ensure that a request isn't granted * earlier than 200ms after the the last one, then we achieve the intended rate. * If a request comes and the last request was granted only 100ms ago, then we wait for * another 100ms. At this rate, serving 15 fresh permits (i.e. for an acquire(15) request) * naturally takes 3 seconds. æœ€ç®€å•çš„æ§åˆ¶QPSçš„åŠæ³•,å°±æ˜¯æ§åˆ¶æ—¶é—´æˆ³å˜›,åªè¦ä¿è¯è‡ªä»ä¸Šä¸€æ¬¡å‘é€ä»¤ç‰Œåˆ°ç°åœ¨å·²ç»ç»è¿‡äº†(1/QPS)ç§’å³å¯,é‚£ä¹ˆ è¿™æ ·å°±ä¿è¯äº†åŸºæœ¬çš„QPS. * It is important to realize that such a RateLimiter has a very superficial memory * of the past: it only remembers the last request. What if the RateLimiter was unused for * a long period of time, then a request arrived and was immediately granted? * This RateLimiter would immediately forget about that past underutilization. This may * result in either underutilization or overflow, depending on the real world consequences * of not using the expected rate. ä¸Šè¿°åšæ³•è™½ç„¶ç®€å•ç²—æš´,ä½†æ˜¯æœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„ä¸€ç‚¹,å°±æ˜¯å®ƒâ€œå¯¹äºè¿‡å»çš„è®¤è¯†å¹¶ä¸å……åˆ†â€--å®ƒä»…è®°ä½äº†ä¸Šä¸€æ¬¡çš„è¯·æ±‚, å¦‚æœRateLimiterå¾ˆä¹…ä¸è¢«ä½¿ç”¨ï¼Œæ–°æ¥äº†ä¸€ä¸ªè¯·æ±‚,å¹¶ä¸”è¿™ä¸ªè¯·æ±‚å¾ˆå¿«ä¼šè·å¾—æŒ‡ä»¤,é‚£ä¹ˆå®ƒæœºä¼š\"å¿˜è®°\"æ‰ä¹‹å‰çš„ä½ä½¿ç”¨ç‡, è¿™å¯èƒ½ä¼šå¯¼è‡´ä¸€äº›é—®é¢˜,å…·ä½“å–å†³äºå…·ä½“çš„åœºæ™¯. * Past underutilization could mean that excess resources are available. Then, the RateLimiter * should speed up for a while, to take advantage of these resources. This is important * when the rate is applied to networking (limiting bandwidth), where past underutilization * typically translates to \"almost empty buffers\", which can be filled immediately. è¿‡å»çš„ä½ä½¿ç”¨ç‡æ„å‘³ç€æœ‰å‰©ä½™çš„å¯ç”¨èµ„æº,æ‰€ä»¥RateLimiterå¯ä»¥æé€Ÿ(??? è¿™é‡Œä¸æ¸…æ¥šåº”è¯¥æ€ä¹ˆç¿»è¯‘)æ¥ä½¿ç”¨è¿™äº›èµ„æº, * On the other hand, past underutilization could mean that \"the server responsible for * handling the request has become less ready for future requests\", i.e. its caches become * stale, and requests become more likely to trigger expensive operations (a more extreme * case of this example is when a server has just booted, and it is mostly busy with getting * itself up to speed). å¦ä¸ªæ–¹é¢è®²,ä½ä½¿ç”¨ç‡æ„å‘³ç€å¤„ç†è¿™äº›è¯·æ±‚çš„æœåŠ¡æœ‰å¯èƒ½è¿˜æ²¡æœ‰å‡†å¤‡å¥½ä½¿ç”¨è¿™äº›è¯·æ±‚,æ¯”å¦‚è¯´å½“æœåŠ¡ä½¿ç”¨åˆ°cacheæ—¶, é‚£ä¹ˆåœ¨é•¿æ—¶é—´çš„é—´éš”ä¹‹åçš„çªç„¶è¯·æ±‚,æœ‰å¯èƒ½ä¼šé€ æˆcacheçš„å¤§é‡miss,æ›´æç«¯çš„è¯·æ±‚æ˜¯å½“æœåŠ¡åˆšå¯åŠ¨æ—¶. * To deal with such scenarios, we add an extra dimension, that of \"past underutilization\", * modeled by \"storedPermits\" variable. This variable is zero when there is no * underutilization, and it can grow up to maxStoredPermits, for sufficiently large * underutilization. So, the requested permits, by an invocation acquire(permits), * are served from: * - stored permits (if available) * - fresh permits (for any remaining permits) ä½œè€…ä½¿ç”¨äº†ä¸€ä¸ªé¢å¤–çš„ç»´åº¦æ¥æè¿°è¿‡å»çš„ä½ä½¿ç”¨ç‡, storedPermits å½“æ–°è¯·æ±‚ä»¤ç‰Œæ—¶,ä»¤ç‰Œä»stored permitså’Œfresh permitsä¸¤ä¸ªåœ°æ–¹è·å¾— * How this works is best explained with an example: * * For a RateLimiter that produces 1 token per second, every second * that goes by with the RateLimiter being unused, we increase storedPermits by 1. * Say we leave the RateLimiter unused for 10 seconds (i.e., we expected a request at time * X, but we are at time X + 10 seconds before a request actually arrives; this is * also related to the point made in the last paragraph), thus storedPermits * becomes 10.0 (assuming maxStoredPermits &gt;= 10.0). At that point, a request of acquire(3) * arrives. We serve this request out of storedPermits, and reduce that to 7.0 (how this is * translated to throttling time is discussed later). Immediately after, assume that an * acquire(10) request arriving. We serve the request partly from storedPermits, * using all the remaining 7.0 permits, and the remaining 3.0, we serve them by fresh permits * produced by the rate limiter. storedPermitså…¶å®æ˜¯ä¸€ä¸ªé¢„å¤‡çš„åº“å­˜çš„æ„æ€,å¦‚æœå…¶ä¸­è¿˜æœ‰ä»¤ç‰Œé¢„å­˜,å°±ç›´æ¥å–,å¦‚æœä¸å¤Ÿçš„è¯,ä¸è¶³çš„éƒ¨åˆ†ç”¨fresh permitsæ¥å¼¥è¡¥ å½“ç„¶,ä½œè€…å°†è¿™äº›è¡¥å¿çš„å…¬å¼éƒ½è½¬æ¢ä¸ºæ—¶é—´ä¸Šçš„è®¡ç®—,è®¡ç®—æ–¹å¼åé¢å†çœ‹ * We already know how much time it takes to serve 3 fresh permits: if the rate is * \"1 token per second\", then this will take 3 seconds. But what does it mean to serve 7 * stored permits? As explained above, there is no unique answer. If we are primarily * interested to deal with underutilization, then we want stored permits to be given out * /faster/ than fresh ones, because underutilization = free resources for the taking. * If we are primarily interested to deal with overflow, then stored permits could * be given out /slower/ than fresh ones. Thus, we require a (different in each case) * function that translates storedPermits to throtting time. å…¶å®æ–°è¯·æ±‚3ä¸ªä»¤ç‰Œçš„æ—¶é—´æ˜¯å®¹æ˜“è®¡ç®—çš„,é‚£ä¹ˆé—®é¢˜å°±åœ¨äºå¦‚ä½•è¡¨ç¤º\"æä¾›7ä¸ªstored permits\"? ä½œè€…è¯´, 1:å¦‚æœè¦åº”å¯¹çš„ä½ä½¿ç”¨ç‡,é‚£ä¹ˆåœ¨æä¾›stored permitsçš„æ—¶å€™å°±éœ€è¦æ¯”fresh permitsè¦\"å¿«\"ä¸€äº›,å› ä¸º å®é™…ä¸Šstored permitså°±æ„å‘³ç€æ˜¯\"é—²ç½®çš„èµ„æº\", 2:å¦‚æœè¦åº”å¯¹çš„æ˜¯è¿‡é«˜ä½¿ç”¨ç‡,é‚£ä¹ˆstored permitså°±éœ€è¦æ…¢ä¸€äº› æ‰€ä»¥ä½œè€…requireäº†ä¸€ä¸ªfunctionæ¥å°†storePermitsè½¬åŒ–ä¸ºthrotting time OK,ä¸‹é¢å°±æ˜¯ç®—æ³•æè¿°,çœ‹ä¸æ‡‚,å…ˆçœ‹ä»£ç ~ * This role is played by storedPermitsToWaitTime(double storedPermits, double permitsToTake). * The underlying model is a continuous function mapping storedPermits * (from 0.0 to maxStoredPermits) onto the 1/rate (i.e. intervals) that is effective at the given * storedPermits. \"storedPermits\" essentially measure unused time; we spend unused time * buying/storing permits. Rate is \"permits / time\", thus \"1 / rate = time / permits\". * Thus, \"1/rate\" (time / permits) times \"permits\" gives time, i.e., integrals on this * function (which is what storedPermitsToWaitTime() computes) correspond to minimum intervals * between subsequent requests, for the specified number of requested permits. * * Here is an example of storedPermitsToWaitTime: * If storedPermits == 10.0, and we want 3 permits, we take them from storedPermits, * reducing them to 7.0, and compute the throttling for these as a call to * storedPermitsToWaitTime(storedPermits = 10.0, permitsToTake = 3.0), which will * evaluate the integral of the function from 7.0 to 10.0. * * Using integrals guarantees that the effect of a single acquire(3) is equivalent * to &#123; acquire(1); acquire(1); acquire(1); &#125;, or &#123; acquire(2); acquire(1); &#125;, etc, * since the integral of the function in [7.0, 10.0] is equivalent to the sum of the * integrals of [7.0, 8.0], [8.0, 9.0], [9.0, 10.0] (and so on), no matter * what the function is. This guarantees that we handle correctly requests of varying weight * (permits), /no matter/ what the actual function is - so we can tweak the latter freely. * (The only requirement, obviously, is that we can compute its integrals). * * Note well that if, for this function, we chose a horizontal line, at height of exactly * (1/QPS), then the effect of the function is non-existent: we serve storedPermits at * exactly the same cost as fresh ones (1/QPS is the cost for each). We use this trick later. * * If we pick a function that goes /below/ that horizontal line, it means that we reduce * the area of the function, thus time. Thus, the RateLimiter becomes /faster/ after a * period of underutilization. If, on the other hand, we pick a function that * goes /above/ that horizontal line, then it means that the area (time) is increased, * thus storedPermits are more costly than fresh permits, thus the RateLimiter becomes * /slower/ after a period of underutilization. * * Last, but not least: consider a RateLimiter with rate of 1 permit per second, currently * completely unused, and an expensive acquire(100) request comes. It would be nonsensical * to just wait for 100 seconds, and /then/ start the actual task. Why wait without doing * anything? A much better approach is to /allow/ the request right away (as if it was an * acquire(1) request instead), and postpone /subsequent/ requests as needed. In this version, * we allow starting the task immediately, and postpone by 100 seconds future requests, * thus we allow for work to get done in the meantime instead of waiting idly. * * This has important consequences: it means that the RateLimiter doesn't remember the time * of the _last_ request, but it remembers the (expected) time of the _next_ request. This * also enables us to tell immediately (see tryAcquire(timeout)) whether a particular * timeout is enough to get us to the point of the next scheduling time, since we always * maintain that. And what we mean by \"an unused RateLimiter\" is also defined by that * notion: when we observe that the \"expected arrival time of the next request\" is actually * in the past, then the difference (now - past) is the amount of time that the RateLimiter * was formally unused, and it is that amount of time which we translate to storedPermits. * (We increase storedPermits with the amount of permits that would have been produced * in that idle time). So, if rate == 1 permit per second, and arrivals come exactly * one second after the previous, then storedPermits is _never_ increased -- we would only * increase it for arrivals _later_ than the expected one second. */ /** * Creates a &#123;@code RateLimiter&#125; with the specified stable throughput, given as * \"permits per second\" (commonly referred to as &lt;i&gt;QPS&lt;/i&gt;, queries per second). * * &lt;p&gt;The returned &#123;@code RateLimiter&#125; ensures that on average no more than &#123;@code * permitsPerSecond&#125; are issued during any given second, with sustained requests * being smoothly spread over each second. When the incoming request rate exceeds * &#123;@code permitsPerSecond&#125; the rate limiter will release one permit every &#123;@code * (1.0 / permitsPerSecond)&#125; seconds. When the rate limiter is unused, * bursts of up to &#123;@code permitsPerSecond&#125; permits will be allowed, with subsequent * requests being smoothly limited at the stable rate of &#123;@code permitsPerSecond&#125;. RateLimiterä¿è¯äº† * @param permitsPerSecond the rate of the returned &#123;@code RateLimiter&#125;, measured in * how many permits become available per second. */ // TODO(user): \"This is equivalent to // &#123;@code createWithCapacity(permitsPerSecond, 1, TimeUnit.SECONDS)&#125;\". public static RateLimiter create(double permitsPerSecond) &#123; /* * The default RateLimiter configuration can save the unused permits of up to one second. * This is to avoid unnecessary stalls in situations like this: A RateLimiter of 1qps, * and 4 threads, all calling acquire() at these moments: * * T0 at 0 seconds * T1 at 1.05 seconds * T2 at 2 seconds * T3 at 3 seconds * * Due to the slight delay of T1, T2 would have to sleep till 2.05 seconds, * and T3 would also have to sleep till 3.05 seconds. */ return create(SleepingTicker.SYSTEM_TICKER, permitsPerSecond); &#125; @VisibleForTesting static RateLimiter create(SleepingTicker ticker, double permitsPerSecond) &#123; RateLimiter rateLimiter = new Bursty(ticker, 1.0 /* maxBurstSeconds */); rateLimiter.setRate(permitsPerSecond); return rateLimiter; &#125; /** * Creates a &#123;@code RateLimiter&#125; with the specified stable throughput, given as * \"permits per second\" (commonly referred to as &lt;i&gt;QPS&lt;/i&gt;, queries per second), and a * &lt;i&gt;warmup period&lt;/i&gt;, during which the &#123;@code RateLimiter&#125; smoothly ramps up its rate, * until it reaches its maximum rate at the end of the period (as long as there are enough * requests to saturate it). Similarly, if the &#123;@code RateLimiter&#125; is left &lt;i&gt;unused&lt;/i&gt; for * a duration of &#123;@code warmupPeriod&#125;, it will gradually return to its \"cold\" state, * i.e. it will go through the same warming up process as when it was first created. * * &lt;p&gt;The returned &#123;@code RateLimiter&#125; is intended for cases where the resource that actually * fulfills the requests (e.g., a remote server) needs \"warmup\" time, rather than * being immediately accessed at the stable (maximum) rate. * * &lt;p&gt;The returned &#123;@code RateLimiter&#125; starts in a \"cold\" state (i.e. the warmup period * will follow), and if it is left unused for long enough, it will return to that state. * * @param permitsPerSecond the rate of the returned &#123;@code RateLimiter&#125;, measured in * how many permits become available per second * @param warmupPeriod the duration of the period where the &#123;@code RateLimiter&#125; ramps up its * rate, before reaching its stable (maximum) rate * @param unit the time unit of the warmupPeriod argument */ public static RateLimiter create(double permitsPerSecond, long warmupPeriod, TimeUnit unit) &#123; return create(SleepingTicker.SYSTEM_TICKER, permitsPerSecond, warmupPeriod, unit); &#125; @VisibleForTesting static RateLimiter create( SleepingTicker ticker, double permitsPerSecond, long warmupPeriod, TimeUnit unit) &#123; RateLimiter rateLimiter = new WarmingUp(ticker, warmupPeriod, unit); rateLimiter.setRate(permitsPerSecond); return rateLimiter; &#125; @VisibleForTesting static RateLimiter createWithCapacity( SleepingTicker ticker, double permitsPerSecond, long maxBurstBuildup, TimeUnit unit) &#123; double maxBurstSeconds = unit.toNanos(maxBurstBuildup) / 1E+9; Bursty rateLimiter = new Bursty(ticker, maxBurstSeconds); rateLimiter.setRate(permitsPerSecond); return rateLimiter; &#125; /** * The underlying timer; used both to measure elapsed time and sleep as necessary. A separate * object to facilitate testing. */ private final SleepingTicker ticker; /** * The timestamp when the RateLimiter was created; used to avoid possible overflow/time-wrapping * errors. */ private final long offsetNanos; /** * The currently stored permits. */ double storedPermits; /** * The maximum number of stored permits. */ double maxPermits; /** * The interval between two unit requests, at our stable rate. E.g., a stable rate of 5 permits * per second has a stable interval of 200ms. */ volatile double stableIntervalMicros; private final Object mutex = new Object(); /** * The time when the next request (no matter its size) will be granted. After granting a request, * this is pushed further in the future. Large requests push this further than small requests. */ private long nextFreeTicketMicros = 0L; // could be either in the past or future private RateLimiter(SleepingTicker ticker) &#123; this.ticker = ticker; this.offsetNanos = ticker.read(); &#125; /** * Updates the stable rate of this &#123;@code RateLimiter&#125;, that is, the * &#123;@code permitsPerSecond&#125; argument provided in the factory method that * constructed the &#123;@code RateLimiter&#125;. Currently throttled threads will &lt;b&gt;not&lt;/b&gt; * be awakened as a result of this invocation, thus they do not observe the new rate; * only subsequent requests will. * * &lt;p&gt;Note though that, since each request repays (by waiting, if necessary) the cost * of the &lt;i&gt;previous&lt;/i&gt; request, this means that the very next request * after an invocation to &#123;@code setRate&#125; will not be affected by the new rate; * it will pay the cost of the previous request, which is in terms of the previous rate. * * &lt;p&gt;The behavior of the &#123;@code RateLimiter&#125; is not modified in any other way, * e.g. if the &#123;@code RateLimiter&#125; was configured with a warmup period of 20 seconds, * it still has a warmup period of 20 seconds after this method invocation. * * @param permitsPerSecond the new stable rate of this &#123;@code RateLimiter&#125;. */ public final void setRate(double permitsPerSecond) &#123; Preconditions.checkArgument(permitsPerSecond &gt; 0.0 &amp;&amp; !Double.isNaN(permitsPerSecond), \"rate must be positive\"); synchronized (mutex) &#123; resync(readSafeMicros()); double stableIntervalMicros = TimeUnit.SECONDS.toMicros(1L) / permitsPerSecond; this.stableIntervalMicros = stableIntervalMicros; doSetRate(permitsPerSecond, stableIntervalMicros); &#125; &#125; abstract void doSetRate(double permitsPerSecond, double stableIntervalMicros); /** * Returns the stable rate (as &#123;@code permits per seconds&#125;) with which this * &#123;@code RateLimiter&#125; is configured with. The initial value of this is the same as * the &#123;@code permitsPerSecond&#125; argument passed in the factory method that produced * this &#123;@code RateLimiter&#125;, and it is only updated after invocations * to &#123;@linkplain #setRate&#125;. */ public final double getRate() &#123; return TimeUnit.SECONDS.toMicros(1L) / stableIntervalMicros; &#125; /** * Acquires a permit from this &#123;@code RateLimiter&#125;, blocking until the request can be granted. * * &lt;p&gt;This method is equivalent to &#123;@code acquire(1)&#125;. */ public void acquire() &#123; acquire(1); &#125; /** * Acquires the given number of permits from this &#123;@code RateLimiter&#125;, blocking until the * request be granted. * * @param permits the number of permits to acquire */ public void acquire(int permits) &#123; checkPermits(permits); long microsToWait; synchronized (mutex) &#123; microsToWait = reserveNextTicket(permits, readSafeMicros()); &#125; ticker.sleepMicrosUninterruptibly(microsToWait); &#125; /** * Acquires a permit from this &#123;@code RateLimiter&#125; if it can be obtained * without exceeding the specified &#123;@code timeout&#125;, or returns &#123;@code false&#125; * immediately (without waiting) if the permit would not have been granted * before the timeout expired. * * &lt;p&gt;This method is equivalent to &#123;@code tryAcquire(1, timeout, unit)&#125;. * * @param timeout the maximum time to wait for the permit * @param unit the time unit of the timeout argument * @return &#123;@code true&#125; if the permit was acquired, &#123;@code false&#125; otherwise */ public boolean tryAcquire(long timeout, TimeUnit unit) &#123; return tryAcquire(1, timeout, unit); &#125; /** * Acquires permits from this &#123;@link RateLimiter&#125; if it can be acquired immediately without delay. * * &lt;p&gt; * This method is equivalent to &#123;@code tryAcquire(permits, 0, anyUnit)&#125;. * * @param permits the number of permits to acquire * @return &#123;@code true&#125; if the permits were acquired, &#123;@code false&#125; otherwise * @since 14.0 */ public boolean tryAcquire(int permits) &#123; return tryAcquire(permits, 0, TimeUnit.MICROSECONDS); &#125; /** * Acquires a permit from this &#123;@link RateLimiter&#125; if it can be acquired immediately without * delay. * * &lt;p&gt; * This method is equivalent to &#123;@code tryAcquire(1)&#125;. * * @return &#123;@code true&#125; if the permit was acquired, &#123;@code false&#125; otherwise * @since 14.0 */ public boolean tryAcquire() &#123; return tryAcquire(1, 0, TimeUnit.MICROSECONDS); &#125; /** * Acquires the given number of permits from this &#123;@code RateLimiter&#125; if it can be obtained * without exceeding the specified &#123;@code timeout&#125;, or returns &#123;@code false&#125; * immediately (without waiting) if the permits would not have been granted * before the timeout expired. * * @param permits the number of permits to acquire * @param timeout the maximum time to wait for the permits * @param unit the time unit of the timeout argument * @return &#123;@code true&#125; if the permits were acquired, &#123;@code false&#125; otherwise */ public boolean tryAcquire(int permits, long timeout, TimeUnit unit) &#123; long timeoutMicros = unit.toMicros(timeout); checkPermits(permits); long microsToWait; synchronized (mutex) &#123; long nowMicros = readSafeMicros(); if (nextFreeTicketMicros &gt; nowMicros + timeoutMicros) &#123; return false; &#125; else &#123; microsToWait = reserveNextTicket(permits, nowMicros); &#125; &#125; ticker.sleepMicrosUninterruptibly(microsToWait); return true; &#125; private static void checkPermits(int permits) &#123; Preconditions.checkArgument(permits &gt; 0, \"Requested permits must be positive\"); &#125; /** * Reserves next ticket and returns the wait time that the caller must wait for. */ private long reserveNextTicket(double requiredPermits, long nowMicros) &#123; resync(nowMicros); long microsToNextFreeTicket = nextFreeTicketMicros - nowMicros; double storedPermitsToSpend = Math.min(requiredPermits, this.storedPermits); double freshPermits = requiredPermits - storedPermitsToSpend; long waitMicros = storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend) + (long) (freshPermits * stableIntervalMicros); this.nextFreeTicketMicros = nextFreeTicketMicros + waitMicros; this.storedPermits -= storedPermitsToSpend; return microsToNextFreeTicket; &#125; /** * Translates a specified portion of our currently stored permits which we want to * spend/acquire, into a throttling time. Conceptually, this evaluates the integral * of the underlying function we use, for the range of * [(storedPermits - permitsToTake), storedPermits]. * * This always holds: &#123;@code 0 &lt;= permitsToTake &lt;= storedPermits&#125; */ abstract long storedPermitsToWaitTime(double storedPermits, double permitsToTake); private void resync(long nowMicros) &#123; // if nextFreeTicket is in the past, resync to now if (nowMicros &gt; nextFreeTicketMicros) &#123; storedPermits = Math.min(maxPermits, storedPermits + (nowMicros - nextFreeTicketMicros) / stableIntervalMicros); nextFreeTicketMicros = nowMicros; &#125; &#125; private long readSafeMicros() &#123; return TimeUnit.NANOSECONDS.toMicros(ticker.read() - offsetNanos); &#125; @Override public String toString() &#123; return String.format(\"RateLimiter[stableRate=%3.1fqps]\", 1000000.0 / stableIntervalMicros); &#125; /** * This implements the following function: * * ^ throttling * | * 3*stable + / * interval | /. * (cold) | / . * | / . &lt;-- \"warmup period\" is the area of the trapezoid between * 2*stable + / . halfPermits and maxPermits * interval | / . * | / . * | / . * stable +----------/ WARM . &#125; * interval | . UP . &#125; &lt;-- this rectangle (from 0 to maxPermits, and * | . PERIOD. &#125; height == stableInterval) defines the cooldown period, * | . . &#125; and we want cooldownPeriod == warmupPeriod * |---------------------------------&gt; storedPermits * (halfPermits) (maxPermits) * * Before going into the details of this particular function, let's keep in mind the basics: * 1) The state of the RateLimiter (storedPermits) is a vertical line in this figure. * 2) When the RateLimiter is not used, this goes right (up to maxPermits) * 3) When the RateLimiter is used, this goes left (down to zero), since if we have storedPermits, * we serve from those first * 4) When _unused_, we go right at the same speed (rate)! I.e., if our rate is * 2 permits per second, and 3 unused seconds pass, we will always save 6 permits * (no matter what our initial position was), up to maxPermits. * If we invert the rate, we get the \"stableInterval\" (interval between two requests * in a perfectly spaced out sequence of requests of the given rate). Thus, if you * want to see \"how much time it will take to go from X storedPermits to X+K storedPermits?\", * the answer is always stableInterval * K. In the same example, for 2 permits per second, * stableInterval is 500ms. Thus to go from X storedPermits to X+6 storedPermits, we * require 6 * 500ms = 3 seconds. * * In short, the time it takes to move to the right (save K permits) is equal to the * rectangle of width == K and height == stableInterval. * 4) When _used_, the time it takes, as explained in the introductory class note, is * equal to the integral of our function, between X permits and X-K permits, assuming * we want to spend K saved permits. * * In summary, the time it takes to move to the left (spend K permits), is equal to the * area of the function of width == K. * * Let's dive into this function now: * * When we have storedPermits &lt;= halfPermits (the left portion of the function), then * we spend them at the exact same rate that * fresh permits would be generated anyway (that rate is 1/stableInterval). We size * this area to be equal to _half_ the specified warmup period. Why we need this? * And why half? We'll explain shortly below (after explaining the second part). * * Stored permits that are beyond halfPermits, are mapped to an ascending line, that goes * from stableInterval to 3 * stableInterval. The average height for that part is * 2 * stableInterval, and is sized appropriately to have an area _equal_ to the * specified warmup period. Thus, by point (4) above, it takes \"warmupPeriod\" amount of time * to go from maxPermits to halfPermits. * * BUT, by point (3) above, it only takes \"warmupPeriod / 2\" amount of time to return back * to maxPermits, from halfPermits! (Because the trapezoid has double the area of the rectangle * of height stableInterval and equivalent width). We decided that the \"cooldown period\" * time should be equivalent to \"warmup period\", thus a fully saturated RateLimiter * (with zero stored permits, serving only fresh ones) can go to a fully unsaturated * (with storedPermits == maxPermits) in the same amount of time it takes for a fully * unsaturated RateLimiter to return to the stableInterval -- which happens in halfPermits, * since beyond that point, we use a horizontal line of \"stableInterval\" height, simulating * the regular rate. * * Thus, we have figured all dimensions of this shape, to give all the desired * properties: * - the width is warmupPeriod / stableInterval, to make cooldownPeriod == warmupPeriod * - the slope starts at the middle, and goes from stableInterval to 3*stableInterval so * to have halfPermits being spend in double the usual time (half the rate), while their * respective rate is steadily ramping up */ private static class WarmingUp extends RateLimiter &#123; final long warmupPeriodMicros; /** * The slope of the line from the stable interval (when permits == 0), to the cold interval * (when permits == maxPermits) */ private double slope; private double halfPermits; WarmingUp(SleepingTicker ticker, long warmupPeriod, TimeUnit timeUnit) &#123; super(ticker); this.warmupPeriodMicros = timeUnit.toMicros(warmupPeriod); &#125; @Override void doSetRate(double permitsPerSecond, double stableIntervalMicros) &#123; double oldMaxPermits = maxPermits; maxPermits = warmupPeriodMicros / stableIntervalMicros; halfPermits = maxPermits / 2.0; // Stable interval is x, cold is 3x, so on average it's 2x. Double the time -&gt; halve the rate double coldIntervalMicros = stableIntervalMicros * 3.0; slope = (coldIntervalMicros - stableIntervalMicros) / halfPermits; if (oldMaxPermits == Double.POSITIVE_INFINITY) &#123; // if we don't special-case this, we would get storedPermits == NaN, below storedPermits = 0.0; &#125; else &#123; storedPermits = (oldMaxPermits == 0.0) ? maxPermits // initial state is cold : storedPermits * maxPermits / oldMaxPermits; &#125; &#125; @Override long storedPermitsToWaitTime(double storedPermits, double permitsToTake) &#123; double availablePermitsAboveHalf = storedPermits - halfPermits; long micros = 0; // measuring the integral on the right part of the function (the climbing line) if (availablePermitsAboveHalf &gt; 0.0) &#123; double permitsAboveHalfToTake = Math.min(availablePermitsAboveHalf, permitsToTake); micros = (long) (permitsAboveHalfToTake * (permitsToTime(availablePermitsAboveHalf) + permitsToTime(availablePermitsAboveHalf - permitsAboveHalfToTake)) / 2.0); permitsToTake -= permitsAboveHalfToTake; &#125; // measuring the integral on the left part of the function (the horizontal line) micros += (stableIntervalMicros * permitsToTake); return micros; &#125; private double permitsToTime(double permits) &#123; return stableIntervalMicros + permits * slope; &#125; &#125; /** * This implements a \"bursty\" RateLimiter, where storedPermits are translated to * zero throttling. The maximum number of permits that can be saved (when the RateLimiter is * unused) is defined in terms of time, in this sense: if a RateLimiter is 2qps, and this * time is specified as 10 seconds, we can save up to 2 * 10 = 20 permits. */ private static class Bursty extends RateLimiter &#123; /** The work (permits) of how many seconds can be saved up if this RateLimiter is unused? */ final double maxBurstSeconds; Bursty(SleepingTicker ticker, double maxBurstSeconds) &#123; super(ticker); this.maxBurstSeconds = maxBurstSeconds; &#125; @Override void doSetRate(double permitsPerSecond, double stableIntervalMicros) &#123; double oldMaxPermits = this.maxPermits; maxPermits = maxBurstSeconds * permitsPerSecond; storedPermits = (oldMaxPermits == 0.0) ? 0.0 // initial state : storedPermits * maxPermits / oldMaxPermits; &#125; @Override long storedPermitsToWaitTime(double storedPermits, double permitsToTake) &#123; return 0L; &#125; &#125; @VisibleForTesting static abstract class SleepingTicker extends Ticker &#123; abstract void sleepMicrosUninterruptibly(long micros); static final SleepingTicker SYSTEM_TICKER = new SleepingTicker() &#123; @Override public long read() &#123; return systemTicker().read(); &#125; @Override public void sleepMicrosUninterruptibly(long micros) &#123; if (micros &gt; 0) &#123; Uninterruptibles.sleepUninterruptibly(micros, TimeUnit.MICROSECONDS); &#125; &#125; &#125;; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://kevingeek.github.io/categories/Java/"}],"tags":[{"name":"RateLimiter","slug":"RateLimiter","permalink":"http://kevingeek.github.io/tags/RateLimiter/"},{"name":"Server","slug":"Server","permalink":"http://kevingeek.github.io/tags/Server/"}]},{"title":"MarkDown å†™æ³•ä¹±å¼¹","slug":"MarkDown","date":"2016-07-25T13:17:17.000Z","updated":"2020-04-17T14:59:31.100Z","comments":true,"path":"2016/07/25/MarkDown/","link":"","permalink":"http://kevingeek.github.io/2016/07/25/MarkDown/","excerpt":"è¿™æ˜¯è¶…é“¾æ¥å¤‡å¿˜å…¨åœ¨è¿™ä¸Šé¢MarkDownè¯­æ³•","text":"è¿™æ˜¯è¶…é“¾æ¥å¤‡å¿˜å…¨åœ¨è¿™ä¸Šé¢MarkDownè¯­æ³• This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. æ ‡é¢˜å“¦This is an H1============= This is an H2ç¬¬ä¸€æ¬¡æ¥è¿™è¾¹å†™æ—¥å¿—ï¼Œç®—æ˜¯ç¬¬ä¸€ç¯‡çœŸæ­£æ„ä¹‰ä¸Šçš„ä¸ªäººblogæ—¥å¿—ï¼Œå¥½çš„å¼€å§‹ï¼ŒHello Worldï¼ Use the printf() function. ä»¥ä¸‹æ˜¯Javaä»£ç  1System.out.println(\"hello world!\"); è¿™æ˜¯å¾ˆé‡è¦çš„ line_number line_two æ©ï¼Œè¿™æ˜¯æ˜Ÿå· æ©ï¼Œè¿™æ˜¯åŠ å· åˆ†å‰²ç¬¦ ç¬¬ä¸€ç‚¹ ç¬¬äºŒç‚¹","categories":[{"name":"feel","slug":"feel","permalink":"http://kevingeek.github.io/categories/feel/"}],"tags":[{"name":"First","slug":"First","permalink":"http://kevingeek.github.io/tags/First/"},{"name":"Second","slug":"Second","permalink":"http://kevingeek.github.io/tags/Second/"}]}],"categories":[{"name":"tech","slug":"tech","permalink":"http://kevingeek.github.io/categories/tech/"},{"name":"normal","slug":"normal","permalink":"http://kevingeek.github.io/categories/normal/"},{"name":"Java","slug":"Java","permalink":"http://kevingeek.github.io/categories/Java/"},{"name":"feel","slug":"feel","permalink":"http://kevingeek.github.io/categories/feel/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kevingeek.github.io/tags/Java/"},{"name":"basic","slug":"basic","permalink":"http://kevingeek.github.io/tags/basic/"},{"name":"In-Memory Data Storage Systems","slug":"In-Memory-Data-Storage-Systems","permalink":"http://kevingeek.github.io/tags/In-Memory-Data-Storage-Systems/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://kevingeek.github.io/tags/Algorithm/"},{"name":"åˆ†å¸ƒå¼","slug":"åˆ†å¸ƒå¼","permalink":"http://kevingeek.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"RateLimiter","slug":"RateLimiter","permalink":"http://kevingeek.github.io/tags/RateLimiter/"},{"name":"Server","slug":"Server","permalink":"http://kevingeek.github.io/tags/Server/"},{"name":"First","slug":"First","permalink":"http://kevingeek.github.io/tags/First/"},{"name":"Second","slug":"Second","permalink":"http://kevingeek.github.io/tags/Second/"}]}