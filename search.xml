<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MarkDown 写法乱弹</title>
    <url>/2016/07/25/MarkDown/</url>
    <content><![CDATA[<blockquote>
<p>这是超链接备忘全在这上面<br><a href="http://www.appinn.com/markdown/" target="_blank" rel="noopener">MarkDown语法</a></p>
</blockquote>
<a id="more"></a>


<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br> consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br> Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
</blockquote>
<blockquote>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>id sem consectetuer libero luctus adipiscing.</p>
</blockquote>
<blockquote>
<p>标题哦<br>This is an H1<br>=============</p>
</blockquote>
<h2 id="This-is-an-H2"><a href="#This-is-an-H2" class="headerlink" title="This is an H2"></a>This is an H2</h2><p>第一次来这边写日志，算是第一篇真正意义上的个人blog日志，好的开始，Hello World！</p>
<p>Use the <code>printf()</code> function.</p>
<blockquote>
<p>以下是Java代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"hello world!"</span>);</span><br></pre></td></tr></table></figure>

<p><em>这是很重要的</em></p>
<ul>
<li>line_number</li>
<li>line_two</li>
<li>恩，这是星号</li>
</ul>
<ul>
<li>恩，这是加号</li>
</ul>
<blockquote>
<p>分割符</p>
</blockquote>
<hr>
<hr>
<ol start="2">
<li>第一点</li>
<li>第二点</li>
</ol>
]]></content>
      <categories>
        <category>feel</category>
      </categories>
      <tags>
        <tag>First</tag>
        <tag>Second</tag>
      </tags>
  </entry>
  <entry>
    <title>限流之RateLimiter</title>
    <url>/2016/10/24/RateLimiter/</url>
    <content><![CDATA[<blockquote>
<p>高并发三板斧,缓存、降级和限流</p>
</blockquote>
<a id="more"></a>

<p>老话说得好，要想服务器耍得好，三板斧不能少，今天我们就来看看其中的一板斧–‘限流’</p>
<h1 id="什么是限流"><a href="#什么是限流" class="headerlink" title="什么是限流"></a><em>什么是限流</em></h1><p>  简单明了的说，在系统当中，有一些第三方应用具有并行能力上限(比如某些垄断行业提供的接口)，你多请求了直接给你返回错误码，还有一些具体的服务，比如秒杀等，仅允许一定的速率来访问特定的资源，在这些应用场景中，就需要用到限流来完成这些事情。</p>
<p>一些通常的case，比如说限制总并发数(DB)，瞬间并发数(Nginx limit_conn)，限制平均速率(RateLimiter)等。而我们今天所要具体讨论的，就是限制平均速率的方法。</p>
<h1 id="两大算法"><a href="#两大算法" class="headerlink" title="两大算法"></a><em>两大算法</em></h1><p>  当然，在此之前我们先来讨论一下限流的两大算法：漏桶、令牌桶。</p>
<h2 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a><em>漏桶</em></h2><p><img src="http://oaxbg6rvg.bkt.clouddn.com/waterDrop.png" alt="waterDrop"></p>
<h2 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a><em>令牌桶</em></h2><p><img src="http://oaxbg6rvg.bkt.clouddn.com/tokenPackage.png" alt="tokenBarierr"></p>
<h1 id="ReteLimiter"><a href="#ReteLimiter" class="headerlink" title="ReteLimiter"></a><em>ReteLimiter</em></h1><p>好啦,那就让我们来看一下令牌桶算法的具体应用,强大的guava包的RateLimiter已经实现了限流,使用的是令牌桶算法,并且可以允许一定程度的<br>请求激增,看起来是非常好的东西<del>简单来说,看注释上来说,是通过时间的换算来等价于令牌的存储的,具体的实现方法,看具体的代码实现吧</del></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2012 The Guava Authors</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    屌屌的，先说明一下是基于Apache2的哦～</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.google.common.util.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.annotations.Beta;</span><br><span class="line"><span class="keyword">import</span> com.google.common.annotations.VisibleForTesting;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Preconditions;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Ticker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.concurrent.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A rate limiter. Conceptually, a rate limiter distributes permits at a</span></span><br><span class="line"><span class="comment"> * configurable rate. Each &#123;<span class="doctag">@link</span> #acquire()&#125; blocks if necessary until a permit is</span></span><br><span class="line"><span class="comment"> * available, and then takes it. Once acquired, permits need not be released.</span></span><br><span class="line"><span class="comment">  字面意思上来说，rateLimiter当然是按照一个给定的速率来进行派发令牌啦～</span></span><br><span class="line"><span class="comment">  执行acquire()方法，会一直阻塞，直到有一个令牌是可用的，然后获得这个令牌，一旦令牌被获得!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  令牌是不需要被 `释放` 的!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Rate limiters are often used to restrict the rate at which some</span></span><br><span class="line"><span class="comment"> * physical or logical resource is accessed. This is in contrast to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.util.concurrent.Semaphore&#125; which restricts the number of concurrent</span></span><br><span class="line"><span class="comment"> * accesses instead of the rate (note though that concurrency and rate are closely related,</span></span><br><span class="line"><span class="comment"> * e.g. see &lt;a href="http://en.wikipedia.org/wiki/Little's_law"&gt;Little's Law&lt;/a&gt;).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  RateLimiter 常常被用来限制某些资源的访问速率。 这和Semaphore不同，Semaphore是用来限制</span></span><br><span class="line"><span class="comment">  并发数而不是速率，这两者还是有不同的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A &#123;<span class="doctag">@code</span> RateLimiter&#125; is defined primarily by the rate at which permits</span></span><br><span class="line"><span class="comment"> * are issued. Absent additional configuration, permits will be distributed at a</span></span><br><span class="line"><span class="comment"> * fixed rate, defined in terms of permits per second. Permits will be distributed</span></span><br><span class="line"><span class="comment"> * smoothly, with the delay between individual permits being adjusted to ensure</span></span><br><span class="line"><span class="comment"> * that the configured rate is maintained.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  如果没有额外的配置，令牌会以固定的速率派发，这个速率以每秒为单位计算。</span></span><br><span class="line"><span class="comment">  令牌将会以平滑的速率派发，单位令牌之间的间隔会被良好调配以保障之前设定好的速率。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;It is possible to configure a &#123;<span class="doctag">@code</span> RateLimiter&#125; to have a warmup</span></span><br><span class="line"><span class="comment"> * period during which time the permits issued each second steadily increases until</span></span><br><span class="line"><span class="comment"> * it hits the stable rate.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  通过配置，也可以使用一个预热的阶段，在这个阶段中每秒分发的令牌数将会递增直到达到边界值为止</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As an example, imagine that we have a list of tasks to execute, but we don't want to</span></span><br><span class="line"><span class="comment"> * submit more than 2 per second:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  一个简单的例子，有一个任务队列需要执行，但是我们不想每秒同时执行的任务超过2个，那么可以这样写</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *&lt;pre&gt;  &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *  final RateLimiter rateLimiter = RateLimiter.create(2.0); // rate is "2 permits per second"</span></span><br><span class="line"><span class="comment"> *  void submitTasks(List&lt;Runnable&gt; tasks, Executor executor) &#123;</span></span><br><span class="line"><span class="comment"> *    for (Runnable task : tasks) &#123;</span></span><br><span class="line"><span class="comment"> *      rateLimiter.acquire(); // may wait</span></span><br><span class="line"><span class="comment"> *      executor.execute(task);</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *  &#125;</span></span><br><span class="line"><span class="comment"> *&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As another example, imagine that we produce a stream of data, and we want to cap it</span></span><br><span class="line"><span class="comment"> * at 5kb per second. This could be accomplished by requiring a permit per byte, and specifying</span></span><br><span class="line"><span class="comment"> * a rate of 5000 permits per second:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  另一个例子就是，想象一下正在处理一个数据流，然后我们想每秒处理5kb。这里的处理方式，为每个byte分配一个令牌，</span></span><br><span class="line"><span class="comment">  并且指定每秒有5000个令牌。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *&lt;pre&gt;  &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *  final RateLimiter rateLimiter = RateLimiter.create(5000.0); // rate = 5000 permits per second</span></span><br><span class="line"><span class="comment"> *  void submitPacket(byte[] packet) &#123;</span></span><br><span class="line"><span class="comment"> *    rateLimiter.acquire(packet.length);</span></span><br><span class="line"><span class="comment"> *    networkService.send(packet);</span></span><br><span class="line"><span class="comment"> *  &#125;</span></span><br><span class="line"><span class="comment"> *&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;It is important to note that the number of permits requested &lt;i&gt;never&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * affect the throttling of the request itself (an invocation to &#123;<span class="doctag">@code</span> acquire(1)&#125;</span></span><br><span class="line"><span class="comment"> * and an invocation to &#123;<span class="doctag">@code</span> acquire(1000)&#125; will result in exactly the same throttling, if any),</span></span><br><span class="line"><span class="comment"> * but it affects the throttling of the &lt;i&gt;next&lt;/i&gt; request. I.e., if an expensive task</span></span><br><span class="line"><span class="comment"> * arrives at an idle RateLimiter, it will be granted immediately, but it is the &lt;i&gt;next&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * request that will experience extra throttling, thus paying for the cost of the expensive</span></span><br><span class="line"><span class="comment"> * task.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  作者提到了很重要的一点，当前请求的令牌数量并不会阻止当前的请求，acquire(1)和acquire(1000)会导致相同的结果，</span></span><br><span class="line"><span class="comment">  如果当前的请求消耗了特别多的令牌，那么是由“下一个请求"来偿还当前这个请求所耗费的令牌。</span></span><br><span class="line"><span class="comment">  这里有点绕，具体还是看代码吧</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: &#123;<span class="doctag">@code</span> RateLimiter&#125; does not provide fairness guarantees.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  嗯...这就是不公平的，就像这个世界一样 =。=   face and embrace it</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dimitris Andreou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 13.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// TODO(user): switch to nano precision. A natural unit of cost is "bytes", and a micro precision</span></span><br><span class="line"><span class="comment">//     would mean a maximum rate of "1MB/s", which might be small in some cases.</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@Beta</span></span><br><span class="line"><span class="comment">// wow， 原来这玩意还只是个Beta版本呀～</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * How is the RateLimiter designed, and why?</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The primary feature of a RateLimiter is its "stable rate", the maximum rate that</span></span><br><span class="line"><span class="comment">   * is should allow at normal conditions. This is enforced by "throttling" incoming</span></span><br><span class="line"><span class="comment">   * requests as needed, i.e. compute, for an incoming request, the appropriate throttle time,</span></span><br><span class="line"><span class="comment">   * and make the calling thread wait as much.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    对于RateLimiter最主要的特性就是“稳定的速率”，在通常情况下，允许以最高的速率进行运作。</span></span><br><span class="line"><span class="comment">    后面的不知道怎么翻译</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The simplest way to maintain a rate of QPS is to keep the timestamp of the last</span></span><br><span class="line"><span class="comment">   * granted request, and ensure that (1/QPS) seconds have elapsed since then. For example,</span></span><br><span class="line"><span class="comment">   * for a rate of QPS=5 (5 tokens per second), if we ensure that a request isn't granted</span></span><br><span class="line"><span class="comment">   * earlier than 200ms after the the last one, then we achieve the intended rate.</span></span><br><span class="line"><span class="comment">   * If a request comes and the last request was granted only 100ms ago, then we wait for</span></span><br><span class="line"><span class="comment">   * another 100ms. At this rate, serving 15 fresh permits (i.e. for an acquire(15) request)</span></span><br><span class="line"><span class="comment">   * naturally takes 3 seconds.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    最简单的控制QPS的办法,就是控制时间戳嘛,只要保证自从上一次发送令牌到现在已经经过了(1/QPS)秒即可,那么</span></span><br><span class="line"><span class="comment">    这样就保证了基本的QPS.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * It is important to realize that such a RateLimiter has a very superficial memory</span></span><br><span class="line"><span class="comment">   * of the past: it only remembers the last request. What if the RateLimiter was unused for</span></span><br><span class="line"><span class="comment">   * a long period of time, then a request arrived and was immediately granted?</span></span><br><span class="line"><span class="comment">   * This RateLimiter would immediately forget about that past underutilization. This may</span></span><br><span class="line"><span class="comment">   * result in either underutilization or overflow, depending on the real world consequences</span></span><br><span class="line"><span class="comment">   * of not using the expected rate.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    上述做法虽然简单粗暴,但是有一个很重要的一点,就是它“对于过去的认识并不充分”--它仅记住了上一次的请求,</span></span><br><span class="line"><span class="comment">    如果RateLimiter很久不被使用，新来了一个请求,并且这个请求很快会获得指令,那么它机会"忘记"掉之前的低使用率,</span></span><br><span class="line"><span class="comment">    这可能会导致一些问题,具体取决于具体的场景.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * Past underutilization could mean that excess resources are available. Then, the RateLimiter</span></span><br><span class="line"><span class="comment">   * should speed up for a while, to take advantage of these resources. This is important</span></span><br><span class="line"><span class="comment">   * when the rate is applied to networking (limiting bandwidth), where past underutilization</span></span><br><span class="line"><span class="comment">   * typically translates to "almost empty buffers", which can be filled immediately.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   过去的低使用率意味着有剩余的可用资源,所以RateLimiter可以提速(??? 这里不清楚应该怎么翻译)来使用这些资源,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * On the other hand, past underutilization could mean that "the server responsible for</span></span><br><span class="line"><span class="comment">   * handling the request has become less ready for future requests", i.e. its caches become</span></span><br><span class="line"><span class="comment">   * stale, and requests become more likely to trigger expensive operations (a more extreme</span></span><br><span class="line"><span class="comment">   * case of this example is when a server has just booted, and it is mostly busy with getting</span></span><br><span class="line"><span class="comment">   * itself up to speed).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    另个方面讲,低使用率意味着处理这些请求的服务有可能还没有准备好使用这些请求,比如说当服务使用到cache时,</span></span><br><span class="line"><span class="comment">    那么在长时间的间隔之后的突然请求,有可能会造成cache的大量miss,更极端的请求是当服务刚启动时.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * To deal with such scenarios, we add an extra dimension, that of "past underutilization",</span></span><br><span class="line"><span class="comment">   * modeled by "storedPermits" variable. This variable is zero when there is no</span></span><br><span class="line"><span class="comment">   * underutilization, and it can grow up to maxStoredPermits, for sufficiently large</span></span><br><span class="line"><span class="comment">   * underutilization. So, the requested permits, by an invocation acquire(permits),</span></span><br><span class="line"><span class="comment">   * are served from:</span></span><br><span class="line"><span class="comment">   * - stored permits (if available)</span></span><br><span class="line"><span class="comment">   * - fresh permits (for any remaining permits)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    作者使用了一个额外的维度来描述过去的低使用率, storedPermits</span></span><br><span class="line"><span class="comment">    当新请求令牌时,令牌从stored permits和fresh permits两个地方获得</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * How this works is best explained with an example:</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * For a RateLimiter that produces 1 token per second, every second</span></span><br><span class="line"><span class="comment">   * that goes by with the RateLimiter being unused, we increase storedPermits by 1.</span></span><br><span class="line"><span class="comment">   * Say we leave the RateLimiter unused for 10 seconds (i.e., we expected a request at time</span></span><br><span class="line"><span class="comment">   * X, but we are at time X + 10 seconds before a request actually arrives; this is</span></span><br><span class="line"><span class="comment">   * also related to the point made in the last paragraph), thus storedPermits</span></span><br><span class="line"><span class="comment">   * becomes 10.0 (assuming maxStoredPermits &gt;= 10.0). At that point, a request of acquire(3)</span></span><br><span class="line"><span class="comment">   * arrives. We serve this request out of storedPermits, and reduce that to 7.0 (how this is</span></span><br><span class="line"><span class="comment">   * translated to throttling time is discussed later). Immediately after, assume that an</span></span><br><span class="line"><span class="comment">   * acquire(10) request arriving. We serve the request partly from storedPermits,</span></span><br><span class="line"><span class="comment">   * using all the remaining 7.0 permits, and the remaining 3.0, we serve them by fresh permits</span></span><br><span class="line"><span class="comment">   * produced by the rate limiter.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    storedPermits其实是一个预备的库存的意思,如果其中还有令牌预存,就直接取,如果不够的话,不足的部分用fresh</span></span><br><span class="line"><span class="comment">    permits来弥补</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    当然,作者将这些补偿的公式都转换为时间上的计算,计算方式后面再看</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * We already know how much time it takes to serve 3 fresh permits: if the rate is</span></span><br><span class="line"><span class="comment">   * "1 token per second", then this will take 3 seconds. But what does it mean to serve 7</span></span><br><span class="line"><span class="comment">   * stored permits? As explained above, there is no unique answer. If we are primarily</span></span><br><span class="line"><span class="comment">   * interested to deal with underutilization, then we want stored permits to be given out</span></span><br><span class="line"><span class="comment">   * /faster/ than fresh ones, because underutilization = free resources for the taking.</span></span><br><span class="line"><span class="comment">   * If we are primarily interested to deal with overflow, then stored permits could</span></span><br><span class="line"><span class="comment">   * be given out /slower/ than fresh ones. Thus, we require a (different in each case)</span></span><br><span class="line"><span class="comment">   * function that translates storedPermits to throtting time.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    其实新请求3个令牌的时间是容易计算的,那么问题就在于如何表示"提供7个stored permits"?</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    作者说,</span></span><br><span class="line"><span class="comment">    1:如果要应对的低使用率,那么在提供stored permits的时候就需要比fresh permits要"快"一些,因为</span></span><br><span class="line"><span class="comment">    实际上stored permits就意味着是"闲置的资源",</span></span><br><span class="line"><span class="comment">    2:如果要应对的是过高使用率,那么stored permits就需要慢一些</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    所以作者require了一个function来将storePermits转化为throtting time</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    OK,下面就是算法描述,看不懂,先看代码~</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * This role is played by storedPermitsToWaitTime(double storedPermits, double permitsToTake).</span></span><br><span class="line"><span class="comment">   * The underlying model is a continuous function mapping storedPermits</span></span><br><span class="line"><span class="comment">   * (from 0.0 to maxStoredPermits) onto the 1/rate (i.e. intervals) that is effective at the given</span></span><br><span class="line"><span class="comment">   * storedPermits. "storedPermits" essentially measure unused time; we spend unused time</span></span><br><span class="line"><span class="comment">   * buying/storing permits. Rate is "permits / time", thus "1 / rate = time / permits".</span></span><br><span class="line"><span class="comment">   * Thus, "1/rate" (time / permits) times "permits" gives time, i.e., integrals on this</span></span><br><span class="line"><span class="comment">   * function (which is what storedPermitsToWaitTime() computes) correspond to minimum intervals</span></span><br><span class="line"><span class="comment">   * between subsequent requests, for the specified number of requested permits.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Here is an example of storedPermitsToWaitTime:</span></span><br><span class="line"><span class="comment">   * If storedPermits == 10.0, and we want 3 permits, we take them from storedPermits,</span></span><br><span class="line"><span class="comment">   * reducing them to 7.0, and compute the throttling for these as a call to</span></span><br><span class="line"><span class="comment">   * storedPermitsToWaitTime(storedPermits = 10.0, permitsToTake = 3.0), which will</span></span><br><span class="line"><span class="comment">   * evaluate the integral of the function from 7.0 to 10.0.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Using integrals guarantees that the effect of a single acquire(3) is equivalent</span></span><br><span class="line"><span class="comment">   * to &#123; acquire(1); acquire(1); acquire(1); &#125;, or &#123; acquire(2); acquire(1); &#125;, etc,</span></span><br><span class="line"><span class="comment">   * since the integral of the function in [7.0, 10.0] is equivalent to the sum of the</span></span><br><span class="line"><span class="comment">   * integrals of [7.0, 8.0], [8.0, 9.0], [9.0, 10.0] (and so on), no matter</span></span><br><span class="line"><span class="comment">   * what the function is. This guarantees that we handle correctly requests of varying weight</span></span><br><span class="line"><span class="comment">   * (permits), /no matter/ what the actual function is - so we can tweak the latter freely.</span></span><br><span class="line"><span class="comment">   * (The only requirement, obviously, is that we can compute its integrals).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Note well that if, for this function, we chose a horizontal line, at height of exactly</span></span><br><span class="line"><span class="comment">   * (1/QPS), then the effect of the function is non-existent: we serve storedPermits at</span></span><br><span class="line"><span class="comment">   * exactly the same cost as fresh ones (1/QPS is the cost for each). We use this trick later.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * If we pick a function that goes /below/ that horizontal line, it means that we reduce</span></span><br><span class="line"><span class="comment">   * the area of the function, thus time. Thus, the RateLimiter becomes /faster/ after a</span></span><br><span class="line"><span class="comment">   * period of underutilization. If, on the other hand, we pick a function that</span></span><br><span class="line"><span class="comment">   * goes /above/ that horizontal line, then it means that the area (time) is increased,</span></span><br><span class="line"><span class="comment">   * thus storedPermits are more costly than fresh permits, thus the RateLimiter becomes</span></span><br><span class="line"><span class="comment">   * /slower/ after a period of underutilization.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Last, but not least: consider a RateLimiter with rate of 1 permit per second, currently</span></span><br><span class="line"><span class="comment">   * completely unused, and an expensive acquire(100) request comes. It would be nonsensical</span></span><br><span class="line"><span class="comment">   * to just wait for 100 seconds, and /then/ start the actual task. Why wait without doing</span></span><br><span class="line"><span class="comment">   * anything? A much better approach is to /allow/ the request right away (as if it was an</span></span><br><span class="line"><span class="comment">   * acquire(1) request instead), and postpone /subsequent/ requests as needed. In this version,</span></span><br><span class="line"><span class="comment">   * we allow starting the task immediately, and postpone by 100 seconds future requests,</span></span><br><span class="line"><span class="comment">   * thus we allow for work to get done in the meantime instead of waiting idly.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * This has important consequences: it means that the RateLimiter doesn't remember the time</span></span><br><span class="line"><span class="comment">   * of the _last_ request, but it remembers the (expected) time of the _next_ request. This</span></span><br><span class="line"><span class="comment">   * also enables us to tell immediately (see tryAcquire(timeout)) whether a particular</span></span><br><span class="line"><span class="comment">   * timeout is enough to get us to the point of the next scheduling time, since we always</span></span><br><span class="line"><span class="comment">   * maintain that. And what we mean by "an unused RateLimiter" is also defined by that</span></span><br><span class="line"><span class="comment">   * notion: when we observe that the "expected arrival time of the next request" is actually</span></span><br><span class="line"><span class="comment">   * in the past, then the difference (now - past) is the amount of time that the RateLimiter</span></span><br><span class="line"><span class="comment">   * was formally unused, and it is that amount of time which we translate to storedPermits.</span></span><br><span class="line"><span class="comment">   * (We increase storedPermits with the amount of permits that would have been produced</span></span><br><span class="line"><span class="comment">   * in that idle time). So, if rate == 1 permit per second, and arrivals come exactly</span></span><br><span class="line"><span class="comment">   * one second after the previous, then storedPermits is _never_ increased -- we would only</span></span><br><span class="line"><span class="comment">   * increase it for arrivals _later_ than the expected one second.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a &#123;<span class="doctag">@code</span> RateLimiter&#125; with the specified stable throughput, given as</span></span><br><span class="line"><span class="comment">   * "permits per second" (commonly referred to as &lt;i&gt;QPS&lt;/i&gt;, queries per second).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;The returned &#123;<span class="doctag">@code</span> RateLimiter&#125; ensures that on average no more than &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">   * permitsPerSecond&#125; are issued during any given second, with sustained requests</span></span><br><span class="line"><span class="comment">   * being smoothly spread over each second. When the incoming request rate exceeds</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> permitsPerSecond&#125; the rate limiter will release one permit every &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">   * (1.0 / permitsPerSecond)&#125; seconds. When the rate limiter is unused,</span></span><br><span class="line"><span class="comment">   * bursts of up to &#123;<span class="doctag">@code</span> permitsPerSecond&#125; permits will be allowed, with subsequent</span></span><br><span class="line"><span class="comment">   * requests being smoothly limited at the stable rate of &#123;<span class="doctag">@code</span> permitsPerSecond&#125;.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RateLimiter保证了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> permitsPerSecond the rate of the returned &#123;<span class="doctag">@code</span> RateLimiter&#125;, measured in</span></span><br><span class="line"><span class="comment">   *        how many permits become available per second.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// TODO(user): "This is equivalent to</span></span><br><span class="line">  <span class="comment">//                 &#123;@code createWithCapacity(permitsPerSecond, 1, TimeUnit.SECONDS)&#125;".</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(<span class="keyword">double</span> permitsPerSecond)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * The default RateLimiter configuration can save the unused permits of up to one second.</span></span><br><span class="line"><span class="comment">       * This is to avoid unnecessary stalls in situations like this: A RateLimiter of 1qps,</span></span><br><span class="line"><span class="comment">       * and 4 threads, all calling acquire() at these moments:</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * T0 at 0 seconds</span></span><br><span class="line"><span class="comment">       * T1 at 1.05 seconds</span></span><br><span class="line"><span class="comment">       * T2 at 2 seconds</span></span><br><span class="line"><span class="comment">       * T3 at 3 seconds</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * Due to the slight delay of T1, T2 would have to sleep till 2.05 seconds,</span></span><br><span class="line"><span class="comment">       * and T3 would also have to sleep till 3.05 seconds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> create(SleepingTicker.SYSTEM_TICKER, permitsPerSecond);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(SleepingTicker ticker, <span class="keyword">double</span> permitsPerSecond)</span> </span>&#123;</span><br><span class="line">    RateLimiter rateLimiter = <span class="keyword">new</span> Bursty(ticker, <span class="number">1.0</span> <span class="comment">/* maxBurstSeconds */</span>);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a &#123;<span class="doctag">@code</span> RateLimiter&#125; with the specified stable throughput, given as</span></span><br><span class="line"><span class="comment">   * "permits per second" (commonly referred to as &lt;i&gt;QPS&lt;/i&gt;, queries per second), and a</span></span><br><span class="line"><span class="comment">   * &lt;i&gt;warmup period&lt;/i&gt;, during which the &#123;<span class="doctag">@code</span> RateLimiter&#125; smoothly ramps up its rate,</span></span><br><span class="line"><span class="comment">   * until it reaches its maximum rate at the end of the period (as long as there are enough</span></span><br><span class="line"><span class="comment">   * requests to saturate it). Similarly, if the &#123;<span class="doctag">@code</span> RateLimiter&#125; is left &lt;i&gt;unused&lt;/i&gt; for</span></span><br><span class="line"><span class="comment">   * a duration of &#123;<span class="doctag">@code</span> warmupPeriod&#125;, it will gradually return to its "cold" state,</span></span><br><span class="line"><span class="comment">   * i.e. it will go through the same warming up process as when it was first created.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;The returned &#123;<span class="doctag">@code</span> RateLimiter&#125; is intended for cases where the resource that actually</span></span><br><span class="line"><span class="comment">   * fulfills the requests (e.g., a remote server) needs "warmup" time, rather than</span></span><br><span class="line"><span class="comment">   * being immediately accessed at the stable (maximum) rate.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;The returned &#123;<span class="doctag">@code</span> RateLimiter&#125; starts in a "cold" state (i.e. the warmup period</span></span><br><span class="line"><span class="comment">   * will follow), and if it is left unused for long enough, it will return to that state.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> permitsPerSecond the rate of the returned &#123;<span class="doctag">@code</span> RateLimiter&#125;, measured in</span></span><br><span class="line"><span class="comment">   *        how many permits become available per second</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> warmupPeriod the duration of the period where the &#123;<span class="doctag">@code</span> RateLimiter&#125; ramps up its</span></span><br><span class="line"><span class="comment">   *        rate, before reaching its stable (maximum) rate</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> unit the time unit of the warmupPeriod argument</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> warmupPeriod, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(SleepingTicker.SYSTEM_TICKER, permitsPerSecond, warmupPeriod, unit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      SleepingTicker ticker, <span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> warmupPeriod, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    RateLimiter rateLimiter = <span class="keyword">new</span> WarmingUp(ticker, warmupPeriod, unit);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> RateLimiter <span class="title">createWithCapacity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      SleepingTicker ticker, <span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> maxBurstBuildup, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> maxBurstSeconds = unit.toNanos(maxBurstBuildup) / <span class="number">1E+9</span>;</span><br><span class="line">    Bursty rateLimiter = <span class="keyword">new</span> Bursty(ticker, maxBurstSeconds);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The underlying timer; used both to measure elapsed time and sleep as necessary. A separate</span></span><br><span class="line"><span class="comment">   * object to facilitate testing.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SleepingTicker ticker;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The timestamp when the RateLimiter was created; used to avoid possible overflow/time-wrapping</span></span><br><span class="line"><span class="comment">   * errors.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> offsetNanos;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The currently stored permits.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">double</span> storedPermits;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The maximum number of stored permits.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">double</span> maxPermits;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The interval between two unit requests, at our stable rate. E.g., a stable rate of 5 permits</span></span><br><span class="line"><span class="comment">   * per second has a stable interval of 200ms.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">double</span> stableIntervalMicros;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object mutex = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The time when the next request (no matter its size) will be granted. After granting a request,</span></span><br><span class="line"><span class="comment">   * this is pushed further in the future. Large requests push this further than small requests.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> nextFreeTicketMicros = <span class="number">0L</span>; <span class="comment">// could be either in the past or future</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">RateLimiter</span><span class="params">(SleepingTicker ticker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ticker = ticker;</span><br><span class="line">    <span class="keyword">this</span>.offsetNanos = ticker.read();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Updates the stable rate of this &#123;<span class="doctag">@code</span> RateLimiter&#125;, that is, the</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> permitsPerSecond&#125; argument provided in the factory method that</span></span><br><span class="line"><span class="comment">   * constructed the &#123;<span class="doctag">@code</span> RateLimiter&#125;. Currently throttled threads will &lt;b&gt;not&lt;/b&gt;</span></span><br><span class="line"><span class="comment">   * be awakened as a result of this invocation, thus they do not observe the new rate;</span></span><br><span class="line"><span class="comment">   * only subsequent requests will.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Note though that, since each request repays (by waiting, if necessary) the cost</span></span><br><span class="line"><span class="comment">   * of the &lt;i&gt;previous&lt;/i&gt; request, this means that the very next request</span></span><br><span class="line"><span class="comment">   * after an invocation to &#123;<span class="doctag">@code</span> setRate&#125; will not be affected by the new rate;</span></span><br><span class="line"><span class="comment">   * it will pay the cost of the previous request, which is in terms of the previous rate.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;The behavior of the &#123;<span class="doctag">@code</span> RateLimiter&#125; is not modified in any other way,</span></span><br><span class="line"><span class="comment">   * e.g. if the &#123;<span class="doctag">@code</span> RateLimiter&#125; was configured with a warmup period of 20 seconds,</span></span><br><span class="line"><span class="comment">   * it still has a warmup period of 20 seconds after this method invocation.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> permitsPerSecond the new stable rate of this &#123;<span class="doctag">@code</span> RateLimiter&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkArgument(permitsPerSecond &gt; <span class="number">0.0</span></span><br><span class="line">        &amp;&amp; !Double.isNaN(permitsPerSecond), <span class="string">"rate must be positive"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">      resync(readSafeMicros());</span><br><span class="line">      <span class="keyword">double</span> stableIntervalMicros = TimeUnit.SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;</span><br><span class="line">      <span class="keyword">this</span>.stableIntervalMicros = stableIntervalMicros;</span><br><span class="line">      doSetRate(permitsPerSecond, stableIntervalMicros);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> stableIntervalMicros)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the stable rate (as &#123;<span class="doctag">@code</span> permits per seconds&#125;) with which this</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> RateLimiter&#125; is configured with. The initial value of this is the same as</span></span><br><span class="line"><span class="comment">   * the &#123;<span class="doctag">@code</span> permitsPerSecond&#125; argument passed in the factory method that produced</span></span><br><span class="line"><span class="comment">   * this &#123;<span class="doctag">@code</span> RateLimiter&#125;, and it is only updated after invocations</span></span><br><span class="line"><span class="comment">   * to &#123;<span class="doctag">@linkplain</span> #setRate&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">getRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TimeUnit.SECONDS.toMicros(<span class="number">1L</span>) / stableIntervalMicros;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Acquires a permit from this &#123;<span class="doctag">@code</span> RateLimiter&#125;, blocking until the request can be granted.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@code</span> acquire(1)&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Acquires the given number of permits from this &#123;<span class="doctag">@code</span> RateLimiter&#125;, blocking until the</span></span><br><span class="line"><span class="comment">   * request be granted.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> permits the number of permits to acquire</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    checkPermits(permits);</span><br><span class="line">    <span class="keyword">long</span> microsToWait;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">      microsToWait = reserveNextTicket(permits, readSafeMicros());</span><br><span class="line">    &#125;</span><br><span class="line">    ticker.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Acquires a permit from this &#123;<span class="doctag">@code</span> RateLimiter&#125; if it can be obtained</span></span><br><span class="line"><span class="comment">   * without exceeding the specified &#123;<span class="doctag">@code</span> timeout&#125;, or returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">   * immediately (without waiting) if the permit would not have been granted</span></span><br><span class="line"><span class="comment">   * before the timeout expired.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@code</span> tryAcquire(1, timeout, unit)&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> timeout the maximum time to wait for the permit</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the permit was acquired, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(<span class="number">1</span>, timeout, unit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Acquires permits from this &#123;<span class="doctag">@link</span> RateLimiter&#125; if it can be acquired immediately without delay.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * This method is equivalent to &#123;<span class="doctag">@code</span> tryAcquire(permits, 0, anyUnit)&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> permits the number of permits to acquire</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the permits were acquired, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 14.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(permits, <span class="number">0</span>, TimeUnit.MICROSECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Acquires a permit from this &#123;<span class="doctag">@link</span> RateLimiter&#125; if it can be acquired immediately without</span></span><br><span class="line"><span class="comment">   * delay.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * This method is equivalent to &#123;<span class="doctag">@code</span> tryAcquire(1)&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the permit was acquired, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 14.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(<span class="number">1</span>, <span class="number">0</span>, TimeUnit.MICROSECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Acquires the given number of permits from this &#123;<span class="doctag">@code</span> RateLimiter&#125; if it can be obtained</span></span><br><span class="line"><span class="comment">   * without exceeding the specified &#123;<span class="doctag">@code</span> timeout&#125;, or returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">   * immediately (without waiting) if the permits would not have been granted</span></span><br><span class="line"><span class="comment">   * before the timeout expired.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> permits the number of permits to acquire</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> timeout the maximum time to wait for the permits</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the permits were acquired, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timeoutMicros = unit.toMicros(timeout);</span><br><span class="line">    checkPermits(permits);</span><br><span class="line">    <span class="keyword">long</span> microsToWait;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">      <span class="keyword">long</span> nowMicros = readSafeMicros();</span><br><span class="line">      <span class="keyword">if</span> (nextFreeTicketMicros &gt; nowMicros + timeoutMicros) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        microsToWait = reserveNextTicket(permits, nowMicros);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ticker.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkPermits</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkArgument(permits &gt; <span class="number">0</span>, <span class="string">"Requested permits must be positive"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Reserves next ticket and returns the wait time that the caller must wait for.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">reserveNextTicket</span><span class="params">(<span class="keyword">double</span> requiredPermits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="keyword">long</span> microsToNextFreeTicket = nextFreeTicketMicros - nowMicros;</span><br><span class="line">    <span class="keyword">double</span> storedPermitsToSpend = Math.min(requiredPermits, <span class="keyword">this</span>.storedPermits);</span><br><span class="line">    <span class="keyword">double</span> freshPermits = requiredPermits - storedPermitsToSpend;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> waitMicros = storedPermitsToWaitTime(<span class="keyword">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">        + (<span class="keyword">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.nextFreeTicketMicros = nextFreeTicketMicros + waitMicros;</span><br><span class="line">    <span class="keyword">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class="line">    <span class="keyword">return</span> microsToNextFreeTicket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Translates a specified portion of our currently stored permits which we want to</span></span><br><span class="line"><span class="comment">   * spend/acquire, into a throttling time. Conceptually, this evaluates the integral</span></span><br><span class="line"><span class="comment">   * of the underlying function we use, for the range of</span></span><br><span class="line"><span class="comment">   * [(storedPermits - permitsToTake), storedPermits].</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * This always holds: &#123;<span class="doctag">@code</span> 0 &lt;= permitsToTake &lt;= storedPermits&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">storedPermitsToWaitTime</span><span class="params">(<span class="keyword">double</span> storedPermits, <span class="keyword">double</span> permitsToTake)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if nextFreeTicket is in the past, resync to now</span></span><br><span class="line">    <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">      storedPermits = Math.min(maxPermits,</span><br><span class="line">          storedPermits + (nowMicros - nextFreeTicketMicros) / stableIntervalMicros);</span><br><span class="line">      nextFreeTicketMicros = nowMicros;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">readSafeMicros</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TimeUnit.NANOSECONDS.toMicros(ticker.read() - offsetNanos);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">"RateLimiter[stableRate=%3.1fqps]"</span>, <span class="number">1000000.0</span> / stableIntervalMicros);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * This implements the following function:</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *          ^ throttling</span></span><br><span class="line"><span class="comment">   *          |</span></span><br><span class="line"><span class="comment">   * 3*stable +                  /</span></span><br><span class="line"><span class="comment">   * interval |                 /.</span></span><br><span class="line"><span class="comment">   *  (cold)  |                / .</span></span><br><span class="line"><span class="comment">   *          |               /  .   &lt;-- "warmup period" is the area of the trapezoid between</span></span><br><span class="line"><span class="comment">   * 2*stable +              /   .       halfPermits and maxPermits</span></span><br><span class="line"><span class="comment">   * interval |             /    .</span></span><br><span class="line"><span class="comment">   *          |            /     .</span></span><br><span class="line"><span class="comment">   *          |           /      .</span></span><br><span class="line"><span class="comment">   *   stable +----------/  WARM . &#125;</span></span><br><span class="line"><span class="comment">   * interval |          .   UP  . &#125; &lt;-- this rectangle (from 0 to maxPermits, and</span></span><br><span class="line"><span class="comment">   *          |          . PERIOD. &#125;     height == stableInterval) defines the cooldown period,</span></span><br><span class="line"><span class="comment">   *          |          .       . &#125;     and we want cooldownPeriod == warmupPeriod</span></span><br><span class="line"><span class="comment">   *          |---------------------------------&gt; storedPermits</span></span><br><span class="line"><span class="comment">   *              (halfPermits) (maxPermits)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Before going into the details of this particular function, let's keep in mind the basics:</span></span><br><span class="line"><span class="comment">   * 1) The state of the RateLimiter (storedPermits) is a vertical line in this figure.</span></span><br><span class="line"><span class="comment">   * 2) When the RateLimiter is not used, this goes right (up to maxPermits)</span></span><br><span class="line"><span class="comment">   * 3) When the RateLimiter is used, this goes left (down to zero), since if we have storedPermits,</span></span><br><span class="line"><span class="comment">   *    we serve from those first</span></span><br><span class="line"><span class="comment">   * 4) When _unused_, we go right at the same speed (rate)! I.e., if our rate is</span></span><br><span class="line"><span class="comment">   *    2 permits per second, and 3 unused seconds pass, we will always save 6 permits</span></span><br><span class="line"><span class="comment">   *    (no matter what our initial position was), up to maxPermits.</span></span><br><span class="line"><span class="comment">   *    If we invert the rate, we get the "stableInterval" (interval between two requests</span></span><br><span class="line"><span class="comment">   *    in a perfectly spaced out sequence of requests of the given rate). Thus, if you</span></span><br><span class="line"><span class="comment">   *    want to see "how much time it will take to go from X storedPermits to X+K storedPermits?",</span></span><br><span class="line"><span class="comment">   *    the answer is always stableInterval * K. In the same example, for 2 permits per second,</span></span><br><span class="line"><span class="comment">   *    stableInterval is 500ms. Thus to go from X storedPermits to X+6 storedPermits, we</span></span><br><span class="line"><span class="comment">   *    require 6 * 500ms = 3 seconds.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *    In short, the time it takes to move to the right (save K permits) is equal to the</span></span><br><span class="line"><span class="comment">   *    rectangle of width == K and height == stableInterval.</span></span><br><span class="line"><span class="comment">   * 4) When _used_, the time it takes, as explained in the introductory class note, is</span></span><br><span class="line"><span class="comment">   *    equal to the integral of our function, between X permits and X-K permits, assuming</span></span><br><span class="line"><span class="comment">   *    we want to spend K saved permits.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *    In summary, the time it takes to move to the left (spend K permits), is equal to the</span></span><br><span class="line"><span class="comment">   *    area of the function of width == K.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Let's dive into this function now:</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * When we have storedPermits &lt;= halfPermits (the left portion of the function), then</span></span><br><span class="line"><span class="comment">   * we spend them at the exact same rate that</span></span><br><span class="line"><span class="comment">   * fresh permits would be generated anyway (that rate is 1/stableInterval). We size</span></span><br><span class="line"><span class="comment">   * this area to be equal to _half_ the specified warmup period. Why we need this?</span></span><br><span class="line"><span class="comment">   * And why half? We'll explain shortly below (after explaining the second part).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Stored permits that are beyond halfPermits, are mapped to an ascending line, that goes</span></span><br><span class="line"><span class="comment">   * from stableInterval to 3 * stableInterval. The average height for that part is</span></span><br><span class="line"><span class="comment">   * 2 * stableInterval, and is sized appropriately to have an area _equal_ to the</span></span><br><span class="line"><span class="comment">   * specified warmup period. Thus, by point (4) above, it takes "warmupPeriod" amount of time</span></span><br><span class="line"><span class="comment">   * to go from maxPermits to halfPermits.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * BUT, by point (3) above, it only takes "warmupPeriod / 2" amount of time to return back</span></span><br><span class="line"><span class="comment">   * to maxPermits, from halfPermits! (Because the trapezoid has double the area of the rectangle</span></span><br><span class="line"><span class="comment">   * of height stableInterval and equivalent width). We decided that the "cooldown period"</span></span><br><span class="line"><span class="comment">   * time should be equivalent to "warmup period", thus a fully saturated RateLimiter</span></span><br><span class="line"><span class="comment">   * (with zero stored permits, serving only fresh ones) can go to a fully unsaturated</span></span><br><span class="line"><span class="comment">   * (with storedPermits == maxPermits) in the same amount of time it takes for a fully</span></span><br><span class="line"><span class="comment">   * unsaturated RateLimiter to return to the stableInterval -- which happens in halfPermits,</span></span><br><span class="line"><span class="comment">   * since beyond that point, we use a horizontal line of "stableInterval" height, simulating</span></span><br><span class="line"><span class="comment">   * the regular rate.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Thus, we have figured all dimensions of this shape, to give all the desired</span></span><br><span class="line"><span class="comment">   * properties:</span></span><br><span class="line"><span class="comment">   * - the width is warmupPeriod / stableInterval, to make cooldownPeriod == warmupPeriod</span></span><br><span class="line"><span class="comment">   * - the slope starts at the middle, and goes from stableInterval to 3*stableInterval so</span></span><br><span class="line"><span class="comment">   *   to have halfPermits being spend in double the usual time (half the rate), while their</span></span><br><span class="line"><span class="comment">   *   respective rate is steadily ramping up</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WarmingUp</span> <span class="keyword">extends</span> <span class="title">RateLimiter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> warmupPeriodMicros;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The slope of the line from the stable interval (when permits == 0), to the cold interval</span></span><br><span class="line"><span class="comment">     * (when permits == maxPermits)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> slope;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> halfPermits;</span><br><span class="line"></span><br><span class="line">    WarmingUp(SleepingTicker ticker, <span class="keyword">long</span> warmupPeriod, TimeUnit timeUnit) &#123;</span><br><span class="line">      <span class="keyword">super</span>(ticker);</span><br><span class="line">      <span class="keyword">this</span>.warmupPeriodMicros = timeUnit.toMicros(warmupPeriod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> stableIntervalMicros)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">double</span> oldMaxPermits = maxPermits;</span><br><span class="line">      maxPermits = warmupPeriodMicros / stableIntervalMicros;</span><br><span class="line">      halfPermits = maxPermits / <span class="number">2.0</span>;</span><br><span class="line">      <span class="comment">// Stable interval is x, cold is 3x, so on average it's 2x. Double the time -&gt; halve the rate</span></span><br><span class="line">      <span class="keyword">double</span> coldIntervalMicros = stableIntervalMicros * <span class="number">3.0</span>;</span><br><span class="line">      slope = (coldIntervalMicros - stableIntervalMicros) / halfPermits;</span><br><span class="line">      <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">        <span class="comment">// if we don't special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">        storedPermits = <span class="number">0.0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        storedPermits = (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">            ? maxPermits <span class="comment">// initial state is cold</span></span><br><span class="line">            : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">storedPermitsToWaitTime</span><span class="params">(<span class="keyword">double</span> storedPermits, <span class="keyword">double</span> permitsToTake)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">double</span> availablePermitsAboveHalf = storedPermits - halfPermits;</span><br><span class="line">      <span class="keyword">long</span> micros = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// measuring the integral on the right part of the function (the climbing line)</span></span><br><span class="line">      <span class="keyword">if</span> (availablePermitsAboveHalf &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> permitsAboveHalfToTake = Math.min(availablePermitsAboveHalf, permitsToTake);</span><br><span class="line">        micros = (<span class="keyword">long</span>) (permitsAboveHalfToTake * (permitsToTime(availablePermitsAboveHalf)</span><br><span class="line">            + permitsToTime(availablePermitsAboveHalf - permitsAboveHalfToTake)) / <span class="number">2.0</span>);</span><br><span class="line">        permitsToTake -= permitsAboveHalfToTake;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// measuring the integral on the left part of the function (the horizontal line)</span></span><br><span class="line">      micros += (stableIntervalMicros * permitsToTake);</span><br><span class="line">      <span class="keyword">return</span> micros;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">permitsToTime</span><span class="params">(<span class="keyword">double</span> permits)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> stableIntervalMicros + permits * slope;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * This implements a "bursty" RateLimiter, where storedPermits are translated to</span></span><br><span class="line"><span class="comment">   * zero throttling. The maximum number of permits that can be saved (when the RateLimiter is</span></span><br><span class="line"><span class="comment">   * unused) is defined in terms of time, in this sense: if a RateLimiter is 2qps, and this</span></span><br><span class="line"><span class="comment">   * time is specified as 10 seconds, we can save up to 2 * 10 = 20 permits.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bursty</span> <span class="keyword">extends</span> <span class="title">RateLimiter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The work (permits) of how many seconds can be saved up if this RateLimiter is unused? */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> maxBurstSeconds;</span><br><span class="line"></span><br><span class="line">    Bursty(SleepingTicker ticker, <span class="keyword">double</span> maxBurstSeconds) &#123;</span><br><span class="line">      <span class="keyword">super</span>(ticker);</span><br><span class="line">      <span class="keyword">this</span>.maxBurstSeconds = maxBurstSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> stableIntervalMicros)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">double</span> oldMaxPermits = <span class="keyword">this</span>.maxPermits;</span><br><span class="line">      maxPermits = maxBurstSeconds * permitsPerSecond;</span><br><span class="line">      storedPermits = (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">          ? <span class="number">0.0</span> <span class="comment">// initial state</span></span><br><span class="line">          : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">storedPermitsToWaitTime</span><span class="params">(<span class="keyword">double</span> storedPermits, <span class="keyword">double</span> permitsToTake)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepingTicker</span> <span class="keyword">extends</span> <span class="title">Ticker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sleepMicrosUninterruptibly</span><span class="params">(<span class="keyword">long</span> micros)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> SleepingTicker SYSTEM_TICKER = <span class="keyword">new</span> SleepingTicker() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> systemTicker().read();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleepMicrosUninterruptibly</span><span class="params">(<span class="keyword">long</span> micros)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (micros &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          Uninterruptibles.sleepUninterruptibly(micros, TimeUnit.MICROSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RateLimiter</tag>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title>苦命管家之巧解草莓风波</title>
    <url>/2017/02/19/Stawberry/</url>
    <content><![CDATA[<p>阿哲是村东边的大户，他有一个特别厉害的管家，能说会道，智商超人，说到草莓风波…</p>
<a id="more"></a>


<h1 id="事起"><a href="#事起" class="headerlink" title="事起"></a>事起</h1><p>老爷平日没啥爱好，年前下苏杭时候碰巧尝了一次草莓，至此每日念念不忘，招来管家…</p>
<h2 id="原来是老爷嘴馋了"><a href="#原来是老爷嘴馋了" class="headerlink" title="原来是老爷嘴馋了"></a>原来是老爷嘴馋了</h2><p>  嘴馋也有讲究，不是胡吃海喝，咱们要持续性发展…<br>  草莓这物件，这年代也没冰箱什么的，最新鲜的就是每日采摘，老爷做的长远打算，每日一醒就对草莓心心念念，所以啊，就想越早越好，晚来一点也没关系，但是必须是今天摘的才行，但是一天都没吃到好草莓，我可是要发飙哦！<br>  还有，这草莓虽好，但是也不能贪杯哦…啊呸，不能多吃，每日一袋是为最好，之后来的，就把他们退掉吧！</p>
<h2 id="老爷想要的是什么"><a href="#老爷想要的是什么" class="headerlink" title="老爷想要的是什么"></a>老爷想要的是什么</h2><p>对于老爷的想法，管家自然是摸得透彻，稍作盘算，就知道老爷想的是啥</p>
<ol>
<li>每天都需要消耗一批草莓(尽最大努力)</li>
<li>每天仅吃一批草莓</li>
<li>只吃当日最新鲜的、质量过关的草莓，至于是谁提供的并不重要</li>
<li>如果有多余的或者不合格的草莓，则需要把他们处理掉(退货)</li>
</ol>
<h2 id="召集商家"><a href="#召集商家" class="headerlink" title="召集商家"></a>召集商家</h2><p>任务吩咐下去，让管家一手操办，老板提出了需求，那管家就只能跑跑腿了～ 要拿到草莓，那得首先联系一下草莓供应商是个什么情况</p>
<p>几日之后，很快就有了消息，这几家供应商，因为草莓属于现摘，每日的情况都不一样，供应商每天送来都货物质量也都参差不齐，需要管家一一验过<br>如果货物质量不行，那么就只能退货啦，又或者我们老爷当日只能吃过草莓了，那么抱歉，你这批货我只能退啦，要是你来的时候，管家还在验上家的货，那你可以碰碰运气，万一上家的货物不过关呢，是吧～</p>
<p>简而言之，市场竞争真是激烈呀！</p>
<p>那么提炼一下：</p>
<ol>
<li>不保证每日都有货物</li>
<li>不保证货物的质量</li>
<li>不保证到货时间</li>
<li>接受退货</li>
<li>供应商在货物送到之前，并不知晓老爷今日是否已经享用了草莓</li>
</ol>
<p>嗯，任性的供应商提供的服务还真是不怎么可靠啊，但是这总难不住聪明的管家，咋一看，虽然每一家货物提供商并不能提供完全可靠的服务，但是我多喊几家一起上，那么老爷的需求还是可以尽量满足的嘛，想到这里，管家就被自己的聪明才智锁折服了，心里还有点小激动呢 (ಡωಡ)hiahiahia</p>
<p>心中一阵盘算之后，通知供应商们召集到院中开了一次集体会议….</p>
<h1 id="一个月黑风高的夜晚"><a href="#一个月黑风高的夜晚" class="headerlink" title="一个月黑风高的夜晚"></a>一个月黑风高的夜晚</h1><p>众商家，今日将大家召集到此，是为了通知各商家之后咱们的统一供货方式，一方面尽量保证老爷的要求，一方面呢，也是和大家打个招呼，咱们以后就按照这个法子来，互通有无嘛</p>
<p>之后每日，若各位货物到后，可将货物先置放于院中，然后由知晓我，待我来对货物进行验收，验收通过之后，向你发放当日款项。若通知我时，我已找到一批新鲜的货物，那么你货的新鲜程度不如上家，自然是输了，那么我就无法给你款项，只能将货退还给你。若我还在验货，那你可以再等等，若之前的货物不合格，那么你可以等等，若上家的货物不符合老爷的要求，那么我就可以来验你的货啦～</p>
<p>各商家见管家提出如此妥善的注意，事少，也不用和别家伤和气，一切买卖全凭本事，一个一个也摩拳擦掌，纷纷表示赞同</p>
<h1 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h1><p>一段时日之后，老爷如愿吃上了想要的草莓🍓，管家也将此方法记录了下来，以便改进与学习 :)</p>
<p>商家p1、p2属于集合P<code>(Provider)</code>，商家提供的服务都是同质的，可以归为一类，分别为</p>
<ol>
<li>送货 deliver</li>
<li>验货 validate</li>
<li>退货 takeBack</li>
</ol>
<p>而管家g<code>(governor)</code>的状态分为几种</p>
<ol>
<li>尚未验货 available</li>
<li>正在验货 validating</li>
<li>验货结束 unavailable</li>
</ol>
<p>那么商家所执行的步骤可以用如下伪代码表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderDeliver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dailyWork</span><span class="params">(Provider p, Governor g)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  p.deliver();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (g.unavailable()) &#123;</span><br><span class="line">    p.takeBack();</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (g.validating()) &#123;</span><br><span class="line">    <span class="comment">// simply wait</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (g.available()) &#123;</span><br><span class="line">    p.validate();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    p.takeBack();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分布式版"><a href="#分布式版" class="headerlink" title="分布式版"></a>分布式版</h1><p>哎呀，老爷一高兴，赏金给得特别高，各路商家接踵而至，管家要忙不过来了，于是吩咐下去几个家丁，分别接待商户，检查依然由管家亲自操作，但商户无需等待，仅需要将货物放在府中，退货由家丁完成，而商户也不直接与管家接触，由家丁负责商家和管家之间的沟通，管家通过府邸中的旗帜表示自己目前正在验货、休息、验货完毕</p>
<p>那么整体的流程作一下简单转换，对商户来说，流程更加简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by kevin on 20/02/2017.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strawberry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger errorCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger takeBackCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger consumedCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger acceptedCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderDeliver2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Provider p;</span><br><span class="line"></span><br><span class="line">        ProviderDeliver2(String name) &#123;</span><br><span class="line">            <span class="keyword">this</span>.p = <span class="keyword">new</span> Provider(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">dailyWork</span><span class="params">(<span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">            Merchandise m = p.deliver(); <span class="comment">// 运送货物</span></span><br><span class="line">            Worker worker = Worker.of(<span class="keyword">this</span>, day); <span class="comment">// 随便找个家丁，并把货物交给他</span></span><br><span class="line">            worker.process(m); <span class="comment">//  家丁来处理货物</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">takeBack</span><span class="params">(Merchandise m)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> res = m.getTime().incrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">1</span>) &#123;</span><br><span class="line">                takeBackCount.incrementAndGet();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"fail! operate "</span> + res );</span><br><span class="line">                errorCount.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Governor g;</span><br><span class="line">        <span class="keyword">private</span> ProviderDeliver2 pd2;</span><br><span class="line"></span><br><span class="line">        Worker(ProviderDeliver2 pd2, Governor g) &#123;</span><br><span class="line">            <span class="keyword">this</span>.pd2 = pd2;</span><br><span class="line">            <span class="keyword">this</span>.g = g;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> Worker <span class="title">of</span><span class="params">(ProviderDeliver2 pd2, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Worker(pd2, Governor.getInstance(day));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(Merchandise m)</span> </span>&#123;</span><br><span class="line">            g.validate(<span class="keyword">this</span>, m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">takeBack</span><span class="params">(Merchandise m)</span> </span>&#123;</span><br><span class="line">            pd2.takeBack(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Governor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> AtomicBoolean available = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">private</span> AtomicBoolean validating = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">private</span> Queue&lt;Merchandise&gt; queue = Queues.newConcurrentLinkedQueue();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> date;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;Integer, Governor&gt; MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> Governor <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> MAP.computeIfAbsent(day, Governor::<span class="keyword">new</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">available</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> available.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Governor</span><span class="params">(<span class="keyword">int</span> date)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.date = date;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">validate</span><span class="params">(Worker worker, Merchandise m)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!available()) &#123;</span><br><span class="line">                    worker.takeBack(m);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.addMerchandise(m);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!validating.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!available()) &#123;</span><br><span class="line">                    cleanAll(worker);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                    Merchandise item = queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (available() &amp;&amp; item.isGood()) &#123;</span><br><span class="line">                        available.set(<span class="keyword">false</span>);</span><br><span class="line">                        acceptedCount.incrementAndGet();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        worker.takeBack(item);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                validating.set(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                consumedCount.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanAll</span><span class="params">(Worker worker)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                Merchandise item = queue.poll();</span><br><span class="line">                worker.takeBack(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addMerchandise</span><span class="params">(Merchandise m)</span> </span>&#123;</span><br><span class="line">            queue.add(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        Provider(String name) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Merchandise <span class="title">deliver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Merchandise(<span class="keyword">this</span>.name + System.nanoTime());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Merchandise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> AtomicInteger time = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> quality = r.nextInt(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">AtomicInteger <span class="title">getTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Merchandise(String name) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            Merchandise that = (Merchandise) o;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(that.name) : that.name == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isGood</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//            return true;</span></span><br><span class="line">            <span class="keyword">return</span> quality &lt; <span class="number">80</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 模仿5个商家，连续提供500日的情况</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> day = <span class="number">0</span>; day &lt; <span class="number">500</span>; day++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmpDay = day;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(() -&gt; <span class="keyword">new</span> ProviderDeliver2(String.valueOf(tmpDay)).dailyWork(tmpDay)).start();</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k != consumedCount.get()) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"done"</span>);</span><br><span class="line">        System.out.println(errorCount.get()); <span class="comment">//0</span></span><br><span class="line">        System.out.println(takeBackCount.get()); <span class="comment">//</span></span><br><span class="line">        System.out.println(acceptedCount.get()); <span class="comment">//</span></span><br><span class="line">        System.out.println(consumedCount.get()); <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>normal</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>2019, New Beginning</title>
    <url>/2019/01/01/hello-world/</url>
    <content><![CDATA[<p><img src="/images/2019-01-01-hello-world/hello-world-tiny.jpeg" alt=""><br>没啥好说的，给您劈个叉吧</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>normal</category>
      </categories>
  </entry>
  <entry>
    <title>Difference Between Redis And Memcache</title>
    <url>/2020/04/08/Difference-Between-Redis-And-Memcache/</url>
    <content><![CDATA[<p>这里主要介绍一下Redis和Memcache的一些异同</p>
<a id="more"></a>

<h1 id="Redis-amp-Memcache，都是基于内存的存储系统，粗略的说"><a href="#Redis-amp-Memcache，都是基于内存的存储系统，粗略的说" class="headerlink" title="Redis &amp; Memcache，都是基于内存的存储系统，粗略的说"></a>Redis &amp; Memcache，都是基于内存的存储系统，粗略的说</h1><ol>
<li>操作上<br>Redis支持服务端的数据操作，（比如incr），但是Memcache不行，需要将值从服务器上取下来，运算，之后再存回Memcache</li>
<li>内存使用率上<br>Memcache的内存使用率比Redis更低。（和内存分配策略，和数据结构有关）</li>
<li>cpu使用上<br>Redis仅支持单核cpu，但是Memcache支持多核cpu</li>
</ol>
<h1 id="再详细点"><a href="#再详细点" class="headerlink" title="再详细点"></a>再详细点</h1><h2 id="1-Redis使用很多的这个数据集合，比如下图中列的"><a href="#1-Redis使用很多的这个数据集合，比如下图中列的" class="headerlink" title="1. Redis使用很多的这个数据集合，比如下图中列的"></a>1. Redis使用很多的这个数据集合，比如下图中列的</h2><ul>
<li>string</li>
<li>hash</li>
<li>list</li>
<li>set</li>
<li>sorted set<br><img src="/images/2020-04-08-Difference-Between-Redis-And-Memcache/RedisDataStructure.png" alt="RedisDataStructure"></li>
</ul>
<h2 id="2-内存管理机制"><a href="#2-内存管理机制" class="headerlink" title="2. 内存管理机制"></a>2. 内存管理机制</h2><p>性能：<br>在redis中，允许存储的内容，比实际的物理内存要更大，当物理内存用完之后，就会使用swap分区。swap操作明显会造成io阻塞<a href="https://redis.io/topics/virtual-memory" target="_blank" rel="noopener">关于VirtualMachine</a><br>而memcache不行，仅支持物理内存操作，所以，从纯速度上来说，memcache的性能要比redis要更好。<br>机制:<br>memcache的内存分布如下所示，其实类似于linux文件系统，存在一定的内存浪费<br><img src="/images/2020-04-08-Difference-Between-Redis-And-Memcache/MemcacheMemoryScheme.png" alt="MemcacheMemoryScheme"></p>
<p>而关于redis的内存分配则是根据基础结构来定的，浪费较少，不过这样的分配容易出现内存碎片问题，官方文档资源则详细得多，我这里直接粘一下好了，一共4点</p>
<ul>
<li>当key被删除的时候，redis不会立刻释放内存，如果使用了5G内存，然后释放了2G，那么实际上的占用依然会是5G</li>
<li>基于第一点，需要预见到实际的redis占用，如果高峰期可能使用到10G，那么就需要提前预备10G的内存（貌似是废话）</li>
<li>如果申请了5G之后，释放了2G，之后又需要使用内存，那么redis会基本上会重复使用这2G的资源（貌似也是废话）</li>
<li>这样的话，碎片率的当 峰值/平时值 比率较高的时候，碎片率会比较高<br>参考部分：<a href="https://redis.io/topics/memory-optimization" target="_blank" rel="noopener">memory-optimization</a></li>
</ul>
<h2 id="3-数据持久化"><a href="#3-数据持久化" class="headerlink" title="3. 数据持久化"></a>3. 数据持久化</h2><p>memcache简单粗暴，直接不支持<br>redis支持，两种模式：rdb快照&amp;AOF文件</p>
<h2 id="4-集群化管理"><a href="#4-集群化管理" class="headerlink" title="4. 集群化管理"></a>4. 集群化管理</h2><ul>
<li>memcache本身对于集群化是无感知的，就是说，可以启动多个memcache节点，完了在客户端通过算法，将数据hash到各个节点上，通过client端的处理来做一个集群<br><img src="/images/2020-04-08-Difference-Between-Redis-And-Memcache/memcacheCluster.png" alt="MemcacheCluster"></li>
<li>redis的集群则可以直接在服务端做处理<br><img src="/images/2020-04-08-Difference-Between-Redis-And-Memcache/redisCluster.png" alt="MemcacheCluster"></li>
</ul>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>In-Memory Data Storage Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>多版本jdk卸载</title>
    <url>/2020/04/14/%E5%A4%9A%E7%89%88%E6%9C%ACjdk%E5%8D%B8%E8%BD%BD/</url>
    <content><![CDATA[<p>之前在机器上有自己安装jdk，后面因为是centos，因为开发工具包的关系所以又安装了open-jdk，导致了是说同时存在多个版本jdk的问题，</p>
<a id="more"></a>

<p>在使用jmap的时候报了如下错误（信息是网上抄的，大致是这个意思）</p>
<pre>
Exception in thread "main" sun.jvm.hotspot.runtime.VMVersionMismatchException:
Supported versions are 1.5.0, 1.5.0_xx. Target VM is 20.6-b01
</pre>

<p>所以需要删掉本机的open-sdk，统一成oracle-jdk，如果java -version出现以下提示，说明默认使用的是open-jdk</p>
<pre>
java version "1.8.0"
OpenJDK  Runtime Environment (build 1.8.0-b09)
OpenJDK 64-Bit Server VM (build 1.8.0-b09, mixed mode)
</pre>

<p>最好还是先卸载掉openjdk,在安装Oracle的jdk,</p>
<p>###<br>1.确定JDK的版本：<br>rpm -qa | grep jdk</p>
<p>可能的结果是：</p>
<p>libgcj-4.1.2-42.el5<br>java-1.4.2-gcj-compat-1.4.2.0-40jpp.115</p>
<p>###<br>2.然后卸载：</p>
<pre><code>
yum -y remove java-1.4.2-gcj-compat-1.4.2.0-40jpp.115
</code></pre>

<p>卸载完成以后，可以用whereis java查看java的路径，</p>
<pre>
java: /opt/java/jdk1.8.0_141/bin/java /opt/java/jdk1.8.0_141/jre/bin/java
</pre>

<p>这时候如果直接用java，可能会报错说 “/usr/bin/java not found”<br>退出终端，并且重新打开一个终端即可</p>
]]></content>
      <tags>
        <tag>basic</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用诊断工具</title>
    <url>/2020/04/16/Java%E5%B8%B8%E7%94%A8%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>开发过程中平时经常用的一些小工具</p>
<a id="more"></a>

<h1 id="Java相关命令"><a href="#Java相关命令" class="headerlink" title="Java相关命令"></a>Java相关命令</h1><p>常用的命令：</p>
<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>通常来说，如果出现程序卡死了（比如restart tomcat的时候），不知道卡哪儿了，咋办呢，用jstack看一下哪个线程在干事</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstack -l $(pid)</span><br></pre></td></tr></table></figure>

<h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>这个貌似就是用来看gc的。。平时一般其他的也都用不上啊</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]</span><br></pre></td></tr></table></figure>

<h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>基本上，用到了jmap就是内存泄漏了<br>常用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap -histo $(pid)</span><br></pre></td></tr></table></figure>

<h2 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h2><p>  发送诊断命令，似乎啥都能干，发送help命令，可以基本看一些能干的事</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jcmd $(pid) help</span><br></pre></td></tr></table></figure>

<h2 id="jmc"><a href="#jmc" class="headerlink" title="jmc"></a>jmc</h2><p>jmc其实就有点意思，说白了是一个特性，配合和jfr使用，</p>
<h1 id="系统相关的命令"><a href="#系统相关的命令" class="headerlink" title="系统相关的命令"></a>系统相关的命令</h1><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>看内存的常用命令，看一下总内存、已用内存、空闲内存、共享内存、buff/cache内存和可用内存的大小<br>以及swap分区的大小（可以看到，我的机器上swap分区大小为0，就是说不会产生swap，直接OOM，避免产生swap机制带来的IO瓶颈问题）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[kevin@ky1 ~]$ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          3.7Gi       823Mi       360Mi       0.0Ki       2.5Gi       2.6Gi</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure>

<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>top命令，集大成，不展开说了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[kevin@ky1 ~]$ top</span><br><span class="line">top - 23:16:12 up 12 days,  4:16,  1 user,  load average: 0.13, 0.04, 0.01</span><br><span class="line">Tasks: 105 total,   1 running, 104 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s):  0.0 us,  3.2 sy,  0.0 ni, 96.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">MiB Mem :   3780.8 total,    360.5 free,    823.7 used,   2596.6 buff/cache</span><br><span class="line">MiB Swap:      0.0 total,      0.0 free,      0.0 used.   2691.2 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line"> 3084 root      10 -10  180812  37704  15780 S   6.7   1.0 219:32.13 AliYunDun</span><br><span class="line">    1 root      20   0  178540  10912   8004 S   0.0   0.3   0:12.98 systemd</span><br><span class="line">    2 root      20   0       0      0      0 S   0.0   0.0   0:00.26 kthreadd</span><br><span class="line">    3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp</span><br><span class="line">    4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_par_gp</span><br></pre></td></tr></table></figure>


<h2 id="pmap"><a href="#pmap" class="headerlink" title="pmap"></a>pmap</h2><p>刚好在网上查到一个特别好的例子这里其实刚好遇到一个特别好的例子<br>开始用NMT和pmap来进行分析内存的分布，这里对于jvm的内存，和真正一个进程锁对应的实际内存是如何分布的，有一个特别深入直观的理解</p>
<p>下面是一个pmap的一个基础输出，（版本不同可能输出不一样）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">START               SIZE     RSS     PSS   DIRTY          SWAP PERM MAPPING</span><br><span class="line">00000000d54aa000  92824K  92824K  92824K  92824K       0K  rw-p   [anon]</span><br><span class="line">00000000daf50000  174784K 174784K 174784K 174784K       0K  rw-p   [anon]</span><br></pre></td></tr></table></figure>

<p> 然后对比一下 NMT 的输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jcmd 14179 VM.native_memory detail</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">14179:</span><br><span class="line"></span><br><span class="line">Native Memory Tracking:</span><br><span class="line"></span><br><span class="line">Total: reserved=653853KB, committed=439409KB</span><br><span class="line">-                 Java Heap (reserved=262144KB, committed=262144KB)</span><br><span class="line">                            (mmap: reserved=262144KB, committed=262144KB)</span><br><span class="line"></span><br><span class="line">-                     Class (reserved=82517KB, committed=81725KB)</span><br><span class="line">                            (classes #17828)</span><br><span class="line">                            (malloc=1317KB #26910)</span><br><span class="line">                            (mmap: reserved=81200KB, committed=80408KB)</span><br><span class="line"></span><br><span class="line">-                    Thread (reserved=20559KB, committed=20559KB)</span><br><span class="line">                            (thread #58)</span><br><span class="line">                            (stack: reserved=20388KB, committed=20388KB)</span><br><span class="line">                            (malloc=102KB #292)</span><br><span class="line">                            (arena=69KB #114)</span><br><span class="line"></span><br><span class="line">-                      Code (reserved=255309KB, committed=41657KB)</span><br><span class="line">                            (malloc=5709KB #11730)</span><br><span class="line">                            (mmap: reserved=249600KB, committed=35948KB)</span><br><span class="line"></span><br><span class="line">-                        GC (reserved=1658KB, committed=1658KB)</span><br><span class="line">                            (malloc=798KB #676)</span><br><span class="line">                            (mmap: reserved=860KB, committed=860KB)</span><br><span class="line"></span><br><span class="line">-                  Compiler (reserved=130KB, committed=130KB)</span><br><span class="line">                            (malloc=31KB #357)</span><br><span class="line">                            (arena=99KB #3)</span><br><span class="line"></span><br><span class="line">-                  Internal (reserved=5039KB, committed=5039KB)</span><br><span class="line">                            (malloc=5007KB #20850)</span><br><span class="line">                            (mmap: reserved=32KB, committed=32KB)</span><br><span class="line"></span><br><span class="line">-                    Symbol (reserved=18402KB, committed=18402KB)</span><br><span class="line">                            (malloc=14972KB #221052)</span><br><span class="line">                            (arena=3430KB #1)</span><br><span class="line"></span><br><span class="line">-    Native Memory Tracking (reserved=2269KB, committed=2269KB)</span><br><span class="line">                            (malloc=53KB #1597)</span><br><span class="line">                            (tracking overhead=2216KB)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-               Arena Chunk (reserved=187KB, committed=187KB)</span><br><span class="line">                            (malloc=187KB)</span><br><span class="line"></span><br><span class="line">-                   Unknown (reserved=5640KB, committed=5640KB)</span><br><span class="line">                            (mmap: reserved=5640KB, committed=5640KB)</span><br><span class="line"> . . .</span><br><span class="line">Virtual memory map:</span><br><span class="line"></span><br><span class="line">[0xceb00000 - 0xcec00000] reserved 1024KB for Class from</span><br><span class="line">[0xced00000 - 0xcee00000] reserved 1024KB for Class from</span><br><span class="line">. . .</span><br><span class="line">[0xcf85e000 - 0xcf8af000] reserved and committed 324KB for Thread Stack from</span><br><span class="line">[0xd4eaf000 - 0xd4f00000] reserved and committed 324KB for Thread Stack from</span><br><span class="line">    [0xf687866e] Thread::record_stack_base_and_size()+0x1be</span><br><span class="line">    [0xf68818bf] JavaThread::run()+0x2f</span><br><span class="line">    [0xf67541f9] java_start(Thread*)+0x119</span><br><span class="line">    [0xf7606395] start_thread+0xd5</span><br><span class="line">//******************** 注意这里</span><br><span class="line">[0xd5a00000 - 0xe5a00000] reserved 262144KB for Java Heap from</span><br><span class="line">//******************** 注意这里</span><br><span class="line">. . .</span><br><span class="line">[0xe5e00000 - 0xf4e00000] reserved 245760KB for Code from</span><br><span class="line">[0xf737f000 - 0xf7400000] reserved 516KB for GC from</span><br><span class="line">[0xf745d000 - 0xf747d000] reserved 128KB for Unknown from</span><br><span class="line">[0xf7700000 - 0xf7751000] reserved and committed 324KB for Thread Stack from</span><br><span class="line">[0xf7762000 - 0xf776a000] reserved and committed 32KB for Internal from</span><br></pre></td></tr></table></figure>

<p>其中有一行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[0xd5a00000 - 0xe5a00000] reserved 262144KB for Java Heap from</span><br></pre></td></tr></table></figure>
<p> 所在的那一行，表示了java的堆内存从0xd5a00000开始<br>辅助上在linux当中，进程的内存分布图，每一块内存是如何分配的就一目了然了</p>
<p><img src="/images/java-tools/pmap.png" alt="pmap"><br>用于对比，附上，虚拟内存空间分布图，<br><img src="/images/java-tools/memory2.png" alt="memory"><br><img src="/images/java-tools/memory.png" alt="memory"></p>
<h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><h2 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h2>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
