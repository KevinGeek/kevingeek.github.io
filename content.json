{"meta":{"title":"å°é£ä¾ ","subtitle":null,"description":null,"author":"kevin","url":"http://kevingeek.github.io"},"pages":[],"posts":[{"title":"2019, New Beginning","slug":"hello-world","date":"2020-04-09T04:19:33.058Z","updated":"2020-04-09T04:19:33.058Z","comments":true,"path":"2020/04/09/hello-world/","link":"","permalink":"http://kevingeek.github.io/2020/04/09/hello-world/","excerpt":"æ²¡å•¥å¥½è¯´çš„ï¼Œç»™æ‚¨åŠˆä¸ªå‰å§","text":"æ²¡å•¥å¥½è¯´çš„ï¼Œç»™æ‚¨åŠˆä¸ªå‰å§","categories":[{"name":"æ—¥å¸¸","slug":"æ—¥å¸¸","permalink":"http://kevingeek.github.io/categories/æ—¥å¸¸/"}],"tags":[]},{"title":"Difference Between Redis And Memcache","slug":"Difference-Between-Redis-And-Memcache","date":"2020-04-08T08:02:02.000Z","updated":"2020-04-09T04:21:08.376Z","comments":true,"path":"2020/04/08/Difference-Between-Redis-And-Memcache/","link":"","permalink":"http://kevingeek.github.io/2020/04/08/Difference-Between-Redis-And-Memcache/","excerpt":"è¿™é‡Œä¸»è¦ä»‹ç»ä¸€ä¸‹Rediså’ŒMemcacheçš„ä¸€äº›å¼‚åŒ","text":"è¿™é‡Œä¸»è¦ä»‹ç»ä¸€ä¸‹Rediså’ŒMemcacheçš„ä¸€äº›å¼‚åŒ Redis &amp; Memcacheï¼Œéƒ½æ˜¯åŸºäºå†…å­˜çš„å­˜å‚¨ç³»ç»Ÿï¼Œç²—ç•¥çš„è¯´ æ“ä½œä¸ŠRedisæ”¯æŒæœåŠ¡ç«¯çš„æ•°æ®æ“ä½œï¼Œï¼ˆæ¯”å¦‚incrï¼‰ï¼Œä½†æ˜¯Memcacheä¸è¡Œï¼Œéœ€è¦å°†å€¼ä»æœåŠ¡å™¨ä¸Šå–ä¸‹æ¥ï¼Œè¿ç®—ï¼Œä¹‹åå†å­˜å›Memcache å†…å­˜ä½¿ç”¨ç‡ä¸ŠMemcacheçš„å†…å­˜ä½¿ç”¨ç‡æ¯”Redisæ›´ä½ã€‚ï¼ˆå’Œå†…å­˜åˆ†é…ç­–ç•¥ï¼Œå’Œæ•°æ®ç»“æ„æœ‰å…³ï¼‰ cpuä½¿ç”¨ä¸ŠRedisä»…æ”¯æŒå•æ ¸cpuï¼Œä½†æ˜¯Memcacheæ”¯æŒå¤šæ ¸cpu å†è¯¦ç»†ç‚¹1. Redisä½¿ç”¨å¾ˆå¤šçš„è¿™ä¸ªæ•°æ®é›†åˆï¼Œæ¯”å¦‚ä¸‹å›¾ä¸­åˆ—çš„ string hash list set sorted set 2. å†…å­˜ç®¡ç†æœºåˆ¶æ€§èƒ½ï¼šåœ¨redisä¸­ï¼Œå…è®¸å­˜å‚¨çš„å†…å®¹ï¼Œæ¯”å®é™…çš„ç‰©ç†å†…å­˜è¦æ›´å¤§ï¼Œå½“ç‰©ç†å†…å­˜ç”¨å®Œä¹‹åï¼Œå°±ä¼šä½¿ç”¨swapåˆ†åŒºã€‚swapæ“ä½œæ˜æ˜¾ä¼šé€ æˆioé˜»å¡å…³äºVirtualMachineè€Œmemcacheä¸è¡Œï¼Œä»…æ”¯æŒç‰©ç†å†…å­˜æ“ä½œï¼Œæ‰€ä»¥ï¼Œä»çº¯é€Ÿåº¦ä¸Šæ¥è¯´ï¼Œmemcacheçš„æ€§èƒ½è¦æ¯”redisè¦æ›´å¥½ã€‚æœºåˆ¶:memcacheçš„å†…å­˜åˆ†å¸ƒå¦‚ä¸‹æ‰€ç¤ºï¼Œå…¶å®ç±»ä¼¼äºlinuxæ–‡ä»¶ç³»ç»Ÿï¼Œå­˜åœ¨ä¸€å®šçš„å†…å­˜æµªè´¹ è€Œå…³äºredisçš„å†…å­˜åˆ†é…åˆ™æ˜¯æ ¹æ®åŸºç¡€ç»“æ„æ¥å®šçš„ï¼Œæµªè´¹è¾ƒå°‘ï¼Œä¸è¿‡è¿™æ ·çš„åˆ†é…å®¹æ˜“å‡ºç°å†…å­˜ç¢ç‰‡é—®é¢˜ï¼Œå®˜æ–¹æ–‡æ¡£èµ„æºåˆ™è¯¦ç»†å¾—å¤šï¼Œæˆ‘è¿™é‡Œç›´æ¥ç²˜ä¸€ä¸‹å¥½äº†ï¼Œä¸€å…±4ç‚¹ å½“keyè¢«åˆ é™¤çš„æ—¶å€™ï¼Œredisä¸ä¼šç«‹åˆ»é‡Šæ”¾å†…å­˜ï¼Œå¦‚æœä½¿ç”¨äº†5Gå†…å­˜ï¼Œç„¶åé‡Šæ”¾äº†2Gï¼Œé‚£ä¹ˆå®é™…ä¸Šçš„å ç”¨ä¾ç„¶ä¼šæ˜¯5G åŸºäºç¬¬ä¸€ç‚¹ï¼Œéœ€è¦é¢„è§åˆ°å®é™…çš„rediså ç”¨ï¼Œå¦‚æœé«˜å³°æœŸå¯èƒ½ä½¿ç”¨åˆ°10Gï¼Œé‚£ä¹ˆå°±éœ€è¦æå‰é¢„å¤‡10Gçš„å†…å­˜ï¼ˆè²Œä¼¼æ˜¯åºŸè¯ï¼‰ å¦‚æœç”³è¯·äº†5Gä¹‹åï¼Œé‡Šæ”¾äº†2Gï¼Œä¹‹ååˆéœ€è¦ä½¿ç”¨å†…å­˜ï¼Œé‚£ä¹ˆredisä¼šåŸºæœ¬ä¸Šä¼šé‡å¤ä½¿ç”¨è¿™2Gçš„èµ„æºï¼ˆè²Œä¼¼ä¹Ÿæ˜¯åºŸè¯ï¼‰ è¿™æ ·çš„è¯ï¼Œç¢ç‰‡ç‡çš„å½“ å³°å€¼/å¹³æ—¶å€¼ æ¯”ç‡è¾ƒé«˜çš„æ—¶å€™ï¼Œç¢ç‰‡ç‡ä¼šæ¯”è¾ƒé«˜å‚è€ƒéƒ¨åˆ†ï¼šmemory-optimization 3. æ•°æ®æŒä¹…åŒ–memcacheç®€å•ç²—æš´ï¼Œç›´æ¥ä¸æ”¯æŒredisæ”¯æŒï¼Œä¸¤ç§æ¨¡å¼ï¼šrdbå¿«ç…§&amp;AOFæ–‡ä»¶ 4. é›†ç¾¤åŒ–ç®¡ç†memcacheæœ¬èº«å¯¹äºé›†ç¾¤åŒ–æ˜¯æ— æ„ŸçŸ¥çš„ï¼Œå°±æ˜¯è¯´ï¼Œå¯ä»¥å¯åŠ¨å¤šä¸ªmemcacheèŠ‚ç‚¹ï¼Œå®Œäº†åœ¨å®¢æˆ·ç«¯é€šè¿‡ç®—æ³•ï¼Œå°†æ•°æ®hashåˆ°å„ä¸ªèŠ‚ç‚¹ä¸Šï¼Œé€šè¿‡clientç«¯çš„å¤„ç†æ¥åšä¸€ä¸ªé›†ç¾¤![memcacheCluster]{memcacheCluster.png}redisçš„é›†ç¾¤åˆ™å¯ä»¥ç›´æ¥åœ¨æœåŠ¡ç«¯åšå¤„ç†ï¼Œ![redisCluster]{redisCluster.png}","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"http://kevingeek.github.io/categories/æŠ€æœ¯/"}],"tags":[{"name":"In-Memory Data Storage Systems","slug":"In-Memory-Data-Storage-Systems","permalink":"http://kevingeek.github.io/tags/In-Memory-Data-Storage-Systems/"}]},{"title":"è‹¦å‘½ç®¡å®¶ä¹‹å·§è§£è‰è“é£æ³¢","slug":"Stawberry","date":"2017-02-19T10:24:50.000Z","updated":"2020-04-09T04:19:33.058Z","comments":true,"path":"2017/02/19/Stawberry/","link":"","permalink":"http://kevingeek.github.io/2017/02/19/Stawberry/","excerpt":"é˜¿å“²æ˜¯æ‘ä¸œè¾¹çš„å¤§æˆ·ï¼Œä»–æœ‰ä¸€ä¸ªç‰¹åˆ«å‰å®³çš„ç®¡å®¶ï¼Œèƒ½è¯´ä¼šé“ï¼Œæ™ºå•†è¶…äººï¼Œè¯´åˆ°è‰è“é£æ³¢â€¦","text":"é˜¿å“²æ˜¯æ‘ä¸œè¾¹çš„å¤§æˆ·ï¼Œä»–æœ‰ä¸€ä¸ªç‰¹åˆ«å‰å®³çš„ç®¡å®¶ï¼Œèƒ½è¯´ä¼šé“ï¼Œæ™ºå•†è¶…äººï¼Œè¯´åˆ°è‰è“é£æ³¢â€¦ äº‹èµ·è€çˆ·å¹³æ—¥æ²¡å•¥çˆ±å¥½ï¼Œå¹´å‰ä¸‹è‹æ­æ—¶å€™ç¢°å·§å°äº†ä¸€æ¬¡è‰è“ï¼Œè‡³æ­¤æ¯æ—¥å¿µå¿µä¸å¿˜ï¼Œæ‹›æ¥ç®¡å®¶â€¦ åŸæ¥æ˜¯è€çˆ·å˜´é¦‹äº† å˜´é¦‹ä¹Ÿæœ‰è®²ç©¶ï¼Œä¸æ˜¯èƒ¡åƒæµ·å–ï¼Œå’±ä»¬è¦æŒç»­æ€§å‘å±•â€¦ è‰è“è¿™ç‰©ä»¶ï¼Œè¿™å¹´ä»£ä¹Ÿæ²¡å†°ç®±ä»€ä¹ˆçš„ï¼Œæœ€æ–°é²œçš„å°±æ˜¯æ¯æ—¥é‡‡æ‘˜ï¼Œè€çˆ·åšçš„é•¿è¿œæ‰“ç®—ï¼Œæ¯æ—¥ä¸€é†’å°±å¯¹è‰è“å¿ƒå¿ƒå¿µå¿µï¼Œæ‰€ä»¥å•Šï¼Œå°±æƒ³è¶Šæ—©è¶Šå¥½ï¼Œæ™šæ¥ä¸€ç‚¹ä¹Ÿæ²¡å…³ç³»ï¼Œä½†æ˜¯å¿…é¡»æ˜¯ä»Šå¤©æ‘˜çš„æ‰è¡Œï¼Œä½†æ˜¯ä¸€å¤©éƒ½æ²¡åƒåˆ°å¥½è‰è“ï¼Œæˆ‘å¯æ˜¯è¦å‘é£™å“¦ï¼ è¿˜æœ‰ï¼Œè¿™è‰è“è™½å¥½ï¼Œä½†æ˜¯ä¹Ÿä¸èƒ½è´ªæ¯å“¦â€¦å•Šå‘¸ï¼Œä¸èƒ½å¤šåƒï¼Œæ¯æ—¥ä¸€è¢‹æ˜¯ä¸ºæœ€å¥½ï¼Œä¹‹åæ¥çš„ï¼Œå°±æŠŠä»–ä»¬é€€æ‰å§ï¼ è€çˆ·æƒ³è¦çš„æ˜¯ä»€ä¹ˆå¯¹äºè€çˆ·çš„æƒ³æ³•ï¼Œç®¡å®¶è‡ªç„¶æ˜¯æ‘¸å¾—é€å½»ï¼Œç¨ä½œç›˜ç®—ï¼Œå°±çŸ¥é“è€çˆ·æƒ³çš„æ˜¯å•¥ æ¯å¤©éƒ½éœ€è¦æ¶ˆè€—ä¸€æ‰¹è‰è“(å°½æœ€å¤§åŠªåŠ›) æ¯å¤©ä»…åƒä¸€æ‰¹è‰è“ åªåƒå½“æ—¥æœ€æ–°é²œçš„ã€è´¨é‡è¿‡å…³çš„è‰è“ï¼Œè‡³äºæ˜¯è°æä¾›çš„å¹¶ä¸é‡è¦ å¦‚æœæœ‰å¤šä½™çš„æˆ–è€…ä¸åˆæ ¼çš„è‰è“ï¼Œåˆ™éœ€è¦æŠŠä»–ä»¬å¤„ç†æ‰(é€€è´§) å¬é›†å•†å®¶ä»»åŠ¡å©å’ä¸‹å»ï¼Œè®©ç®¡å®¶ä¸€æ‰‹æ“åŠï¼Œè€æ¿æå‡ºäº†éœ€æ±‚ï¼Œé‚£ç®¡å®¶å°±åªèƒ½è·‘è·‘è…¿äº†ï½ è¦æ‹¿åˆ°è‰è“ï¼Œé‚£å¾—é¦–å…ˆè”ç³»ä¸€ä¸‹è‰è“ä¾›åº”å•†æ˜¯ä¸ªä»€ä¹ˆæƒ…å†µ å‡ æ—¥ä¹‹åï¼Œå¾ˆå¿«å°±æœ‰äº†æ¶ˆæ¯ï¼Œè¿™å‡ å®¶ä¾›åº”å•†ï¼Œå› ä¸ºè‰è“å±äºç°æ‘˜ï¼Œæ¯æ—¥çš„æƒ…å†µéƒ½ä¸ä¸€æ ·ï¼Œä¾›åº”å•†æ¯å¤©é€æ¥éƒ½è´§ç‰©è´¨é‡ä¹Ÿéƒ½å‚å·®ä¸é½ï¼Œéœ€è¦ç®¡å®¶ä¸€ä¸€éªŒè¿‡å¦‚æœè´§ç‰©è´¨é‡ä¸è¡Œï¼Œé‚£ä¹ˆå°±åªèƒ½é€€è´§å•¦ï¼Œåˆæˆ–è€…æˆ‘ä»¬è€çˆ·å½“æ—¥åªèƒ½åƒè¿‡è‰è“äº†ï¼Œé‚£ä¹ˆæŠ±æ­‰ï¼Œä½ è¿™æ‰¹è´§æˆ‘åªèƒ½é€€å•¦ï¼Œè¦æ˜¯ä½ æ¥çš„æ—¶å€™ï¼Œç®¡å®¶è¿˜åœ¨éªŒä¸Šå®¶çš„è´§ï¼Œé‚£ä½ å¯ä»¥ç¢°ç¢°è¿æ°”ï¼Œä¸‡ä¸€ä¸Šå®¶çš„è´§ç‰©ä¸è¿‡å…³å‘¢ï¼Œæ˜¯å§ï½ ç®€è€Œè¨€ä¹‹ï¼Œå¸‚åœºç«äº‰çœŸæ˜¯æ¿€çƒˆå‘€ï¼ é‚£ä¹ˆæç‚¼ä¸€ä¸‹ï¼š ä¸ä¿è¯æ¯æ—¥éƒ½æœ‰è´§ç‰© ä¸ä¿è¯è´§ç‰©çš„è´¨é‡ ä¸ä¿è¯åˆ°è´§æ—¶é—´ æ¥å—é€€è´§ ä¾›åº”å•†åœ¨è´§ç‰©é€åˆ°ä¹‹å‰ï¼Œå¹¶ä¸çŸ¥æ™“è€çˆ·ä»Šæ—¥æ˜¯å¦å·²ç»äº«ç”¨äº†è‰è“ å—¯ï¼Œä»»æ€§çš„ä¾›åº”å•†æä¾›çš„æœåŠ¡è¿˜çœŸæ˜¯ä¸æ€ä¹ˆå¯é å•Šï¼Œä½†æ˜¯è¿™æ€»éš¾ä¸ä½èªæ˜çš„ç®¡å®¶ï¼Œå’‹ä¸€çœ‹ï¼Œè™½ç„¶æ¯ä¸€å®¶è´§ç‰©æä¾›å•†å¹¶ä¸èƒ½æä¾›å®Œå…¨å¯é çš„æœåŠ¡ï¼Œä½†æ˜¯æˆ‘å¤šå–Šå‡ å®¶ä¸€èµ·ä¸Šï¼Œé‚£ä¹ˆè€çˆ·çš„éœ€æ±‚è¿˜æ˜¯å¯ä»¥å°½é‡æ»¡è¶³çš„å˜›ï¼Œæƒ³åˆ°è¿™é‡Œï¼Œç®¡å®¶å°±è¢«è‡ªå·±çš„èªæ˜æ‰æ™ºé”æŠ˜æœäº†ï¼Œå¿ƒé‡Œè¿˜æœ‰ç‚¹å°æ¿€åŠ¨å‘¢ (à²¡Ï‰à²¡)hiahiahia å¿ƒä¸­ä¸€é˜µç›˜ç®—ä¹‹åï¼Œé€šçŸ¥ä¾›åº”å•†ä»¬å¬é›†åˆ°é™¢ä¸­å¼€äº†ä¸€æ¬¡é›†ä½“ä¼šè®®â€¦. ä¸€ä¸ªæœˆé»‘é£é«˜çš„å¤œæ™šä¼—å•†å®¶ï¼Œä»Šæ—¥å°†å¤§å®¶å¬é›†åˆ°æ­¤ï¼Œæ˜¯ä¸ºäº†é€šçŸ¥å„å•†å®¶ä¹‹åå’±ä»¬çš„ç»Ÿä¸€ä¾›è´§æ–¹å¼ï¼Œä¸€æ–¹é¢å°½é‡ä¿è¯è€çˆ·çš„è¦æ±‚ï¼Œä¸€æ–¹é¢å‘¢ï¼Œä¹Ÿæ˜¯å’Œå¤§å®¶æ‰“ä¸ªæ‹›å‘¼ï¼Œå’±ä»¬ä»¥åå°±æŒ‰ç…§è¿™ä¸ªæ³•å­æ¥ï¼Œäº’é€šæœ‰æ— å˜› ä¹‹åæ¯æ—¥ï¼Œè‹¥å„ä½è´§ç‰©åˆ°åï¼Œå¯å°†è´§ç‰©å…ˆç½®æ”¾äºé™¢ä¸­ï¼Œç„¶åç”±çŸ¥æ™“æˆ‘ï¼Œå¾…æˆ‘æ¥å¯¹è´§ç‰©è¿›è¡ŒéªŒæ”¶ï¼ŒéªŒæ”¶é€šè¿‡ä¹‹åï¼Œå‘ä½ å‘æ”¾å½“æ—¥æ¬¾é¡¹ã€‚è‹¥é€šçŸ¥æˆ‘æ—¶ï¼Œæˆ‘å·²æ‰¾åˆ°ä¸€æ‰¹æ–°é²œçš„è´§ç‰©ï¼Œé‚£ä¹ˆä½ è´§çš„æ–°é²œç¨‹åº¦ä¸å¦‚ä¸Šå®¶ï¼Œè‡ªç„¶æ˜¯è¾“äº†ï¼Œé‚£ä¹ˆæˆ‘å°±æ— æ³•ç»™ä½ æ¬¾é¡¹ï¼Œåªèƒ½å°†è´§é€€è¿˜ç»™ä½ ã€‚è‹¥æˆ‘è¿˜åœ¨éªŒè´§ï¼Œé‚£ä½ å¯ä»¥å†ç­‰ç­‰ï¼Œè‹¥ä¹‹å‰çš„è´§ç‰©ä¸åˆæ ¼ï¼Œé‚£ä¹ˆä½ å¯ä»¥ç­‰ç­‰ï¼Œè‹¥ä¸Šå®¶çš„è´§ç‰©ä¸ç¬¦åˆè€çˆ·çš„è¦æ±‚ï¼Œé‚£ä¹ˆæˆ‘å°±å¯ä»¥æ¥éªŒä½ çš„è´§å•¦ï½ å„å•†å®¶è§ç®¡å®¶æå‡ºå¦‚æ­¤å¦¥å–„çš„æ³¨æ„ï¼Œäº‹å°‘ï¼Œä¹Ÿä¸ç”¨å’Œåˆ«å®¶ä¼¤å’Œæ°”ï¼Œä¸€åˆ‡ä¹°å–å…¨å‡­æœ¬äº‹ï¼Œä¸€ä¸ªä¸€ä¸ªä¹Ÿæ‘©æ‹³æ“¦æŒï¼Œçº·çº·è¡¨ç¤ºèµåŒ å•æœºç‰ˆä¸€æ®µæ—¶æ—¥ä¹‹åï¼Œè€çˆ·å¦‚æ„¿åƒä¸Šäº†æƒ³è¦çš„è‰è“ğŸ“ï¼Œç®¡å®¶ä¹Ÿå°†æ­¤æ–¹æ³•è®°å½•äº†ä¸‹æ¥ï¼Œä»¥ä¾¿æ”¹è¿›ä¸å­¦ä¹  :) å•†å®¶p1ã€p2å±äºé›†åˆP(Provider)ï¼Œå•†å®¶æä¾›çš„æœåŠ¡éƒ½æ˜¯åŒè´¨çš„ï¼Œå¯ä»¥å½’ä¸ºä¸€ç±»ï¼Œåˆ†åˆ«ä¸º é€è´§ deliver éªŒè´§ validate é€€è´§ takeBack è€Œç®¡å®¶g(governor)çš„çŠ¶æ€åˆ†ä¸ºå‡ ç§ å°šæœªéªŒè´§ available æ­£åœ¨éªŒè´§ validating éªŒè´§ç»“æŸ unavailable é‚£ä¹ˆå•†å®¶æ‰€æ‰§è¡Œçš„æ­¥éª¤å¯ä»¥ç”¨å¦‚ä¸‹ä¼ªä»£ç è¡¨ç¤ºï¼š public class ProviderDeliver { public void dailyWork(Provider p, Governor g){} p.deliver(); if (g.unavailable()) { p.takeBack(); return ; } while (g.validating()) { // simply wait } if (g.available()) { p.validate(); } else { p.takeBack(); } } åˆ†å¸ƒå¼ç‰ˆå“å‘€ï¼Œè€çˆ·ä¸€é«˜å…´ï¼Œèµé‡‘ç»™å¾—ç‰¹åˆ«é«˜ï¼Œå„è·¯å•†å®¶æ¥è¸µè€Œè‡³ï¼Œç®¡å®¶è¦å¿™ä¸è¿‡æ¥äº†ï¼Œäºæ˜¯å©å’ä¸‹å»å‡ ä¸ªå®¶ä¸ï¼Œåˆ†åˆ«æ¥å¾…å•†æˆ·ï¼Œæ£€æŸ¥ä¾ç„¶ç”±ç®¡å®¶äº²è‡ªæ“ä½œï¼Œä½†å•†æˆ·æ— éœ€ç­‰å¾…ï¼Œä»…éœ€è¦å°†è´§ç‰©æ”¾åœ¨åºœä¸­ï¼Œé€€è´§ç”±å®¶ä¸å®Œæˆï¼Œè€Œå•†æˆ·ä¹Ÿä¸ç›´æ¥ä¸ç®¡å®¶æ¥è§¦ï¼Œç”±å®¶ä¸è´Ÿè´£å•†å®¶å’Œç®¡å®¶ä¹‹é—´çš„æ²Ÿé€šï¼Œç®¡å®¶é€šè¿‡åºœé‚¸ä¸­çš„æ——å¸œè¡¨ç¤ºè‡ªå·±ç›®å‰æ­£åœ¨éªŒè´§ã€ä¼‘æ¯ã€éªŒè´§å®Œæ¯• é‚£ä¹ˆæ•´ä½“çš„æµç¨‹ä½œä¸€ä¸‹ç®€å•è½¬æ¢ï¼Œå¯¹å•†æˆ·æ¥è¯´ï¼Œæµç¨‹æ›´åŠ ç®€å• /** * * Created by kevin on 20/02/2017. */ public class Strawberry { static AtomicInteger errorCount = new AtomicInteger(0); static AtomicInteger takeBackCount = new AtomicInteger(0); static AtomicInteger consumedCount = new AtomicInteger(0); static AtomicInteger acceptedCount = new AtomicInteger(0); static Random r = new Random(); static class ProviderDeliver2 { private Provider p; ProviderDeliver2(String name) { this.p = new Provider(name); } void dailyWork(int day) { Merchandise m = p.deliver(); // è¿é€è´§ç‰© Worker worker = Worker.of(this, day); // éšä¾¿æ‰¾ä¸ªå®¶ä¸ï¼Œå¹¶æŠŠè´§ç‰©äº¤ç»™ä»– worker.process(m); // å®¶ä¸æ¥å¤„ç†è´§ç‰© } void takeBack(Merchandise m) { int res = m.getTime().incrementAndGet(); if (res == 1) { takeBackCount.incrementAndGet(); } else if (res > 1) { System.out.println(\"fail! operate \" + res ); errorCount.incrementAndGet(); } } } static class Worker { private Governor g; private ProviderDeliver2 pd2; Worker(ProviderDeliver2 pd2, Governor g) { this.pd2 = pd2; this.g = g; } static Worker of(ProviderDeliver2 pd2, int day) { return new Worker(pd2, Governor.getInstance(day)); } void process(Merchandise m) { g.validate(this, m); } void takeBack(Merchandise m) { pd2.takeBack(m); } } static class Governor { private AtomicBoolean available = new AtomicBoolean(true); private AtomicBoolean validating = new AtomicBoolean(false); private Queue queue = Queues.newConcurrentLinkedQueue(); private int date; private static ConcurrentHashMap MAP = new ConcurrentHashMap(); static Governor getInstance(int day) { return MAP.computeIfAbsent(day, Governor::new); } boolean available() { return available.get(); } private Governor(int date) { this.date = date; } void validate(Worker worker, Merchandise m) { try { if (!available()) { worker.takeBack(m); return; } this.addMerchandise(m); if (!validating.compareAndSet(false, true)) { return; } if (!available()) { cleanAll(worker); return; } while (!queue.isEmpty()) { Merchandise item = queue.poll(); if (available() && item.isGood()) { available.set(false); acceptedCount.incrementAndGet(); } else { worker.takeBack(item); } } validating.set(false); } finally { consumedCount.incrementAndGet(); } } private void cleanAll(Worker worker) { while (!queue.isEmpty()) { Merchandise item = queue.poll(); worker.takeBack(item); } } void addMerchandise(Merchandise m) { queue.add(m); } } public static class Provider { private String name; Provider(String name) { this.name = name; } Merchandise deliver() { return new Merchandise(this.name + System.nanoTime()); } } static class Merchandise { private String name; private AtomicInteger time = new AtomicInteger(0); private long quality = r.nextInt(100); AtomicInteger getTime() { return time; } Merchandise(String name) { this.name = name; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Merchandise that = (Merchandise) o; return name != null ? name.equals(that.name) : that.name == null; } @Override public int hashCode() { return name != null ? name.hashCode() : 0; } boolean isGood() { // return true; return quality < 80; } } public static void main(String[] args) throws InterruptedException { // æ¨¡ä»¿5ä¸ªå•†å®¶ï¼Œè¿ç»­æä¾›500æ—¥çš„æƒ…å†µ int k = 0; for (int day = 0; day < 500; day++) { int tmpDay = day; for (int i = 0; i < 5; i++) { new Thread(() -> new ProviderDeliver2(String.valueOf(tmpDay)).dailyWork(tmpDay)).start(); k++; } } while (k != consumedCount.get()) { Thread.sleep(10); } System.out.println(\"done\"); System.out.println(errorCount.get()); //0 System.out.println(takeBackCount.get()); // System.out.println(acceptedCount.get()); // System.out.println(consumedCount.get()); // } }","categories":[{"name":"æ—¥å¸¸","slug":"æ—¥å¸¸","permalink":"http://kevingeek.github.io/categories/æ—¥å¸¸/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://kevingeek.github.io/tags/Algorithm/"},{"name":"åˆ†å¸ƒå¼","slug":"åˆ†å¸ƒå¼","permalink":"http://kevingeek.github.io/tags/åˆ†å¸ƒå¼/"}]},{"title":"é™æµä¹‹RateLimiter","slug":"RateLimiter","date":"2016-10-24T12:59:25.000Z","updated":"2020-04-09T04:19:33.057Z","comments":true,"path":"2016/10/24/RateLimiter/","link":"","permalink":"http://kevingeek.github.io/2016/10/24/RateLimiter/","excerpt":"é«˜å¹¶å‘ä¸‰æ¿æ–§,ç¼“å­˜ã€é™çº§å’Œé™æµ","text":"é«˜å¹¶å‘ä¸‰æ¿æ–§,ç¼“å­˜ã€é™çº§å’Œé™æµ è€è¯è¯´å¾—å¥½ï¼Œè¦æƒ³æœåŠ¡å™¨è€å¾—å¥½ï¼Œä¸‰æ¿æ–§ä¸èƒ½å°‘ï¼Œä»Šå¤©æˆ‘ä»¬å°±æ¥çœ‹çœ‹å…¶ä¸­çš„ä¸€æ¿æ–§â€“â€˜é™æµâ€™ ä»€ä¹ˆæ˜¯é™æµ ç®€å•æ˜äº†çš„è¯´ï¼Œåœ¨ç³»ç»Ÿå½“ä¸­ï¼Œæœ‰ä¸€äº›ç¬¬ä¸‰æ–¹åº”ç”¨å…·æœ‰å¹¶è¡Œèƒ½åŠ›ä¸Šé™(æ¯”å¦‚æŸäº›å„æ–­è¡Œä¸šæä¾›çš„æ¥å£)ï¼Œä½ å¤šè¯·æ±‚äº†ç›´æ¥ç»™ä½ è¿”å›é”™è¯¯ç ï¼Œè¿˜æœ‰ä¸€äº›å…·ä½“çš„æœåŠ¡ï¼Œæ¯”å¦‚ç§’æ€ç­‰ï¼Œä»…å…è®¸ä¸€å®šçš„é€Ÿç‡æ¥è®¿é—®ç‰¹å®šçš„èµ„æºï¼Œåœ¨è¿™äº›åº”ç”¨åœºæ™¯ä¸­ï¼Œå°±éœ€è¦ç”¨åˆ°é™æµæ¥å®Œæˆè¿™äº›äº‹æƒ…ã€‚ ä¸€äº›é€šå¸¸çš„caseï¼Œæ¯”å¦‚è¯´é™åˆ¶æ€»å¹¶å‘æ•°(DB)ï¼Œç¬é—´å¹¶å‘æ•°(Nginx limit_conn)ï¼Œé™åˆ¶å¹³å‡é€Ÿç‡(RateLimiter)ç­‰ã€‚è€Œæˆ‘ä»¬ä»Šå¤©æ‰€è¦å…·ä½“è®¨è®ºçš„ï¼Œå°±æ˜¯é™åˆ¶å¹³å‡é€Ÿç‡çš„æ–¹æ³•ã€‚ ä¸¤å¤§ç®—æ³• å½“ç„¶ï¼Œåœ¨æ­¤ä¹‹å‰æˆ‘ä»¬å…ˆæ¥è®¨è®ºä¸€ä¸‹é™æµçš„ä¸¤å¤§ç®—æ³•ï¼šæ¼æ¡¶ã€ä»¤ç‰Œæ¡¶ã€‚ æ¼æ¡¶ ä»¤ç‰Œæ¡¶ ReteLimiterå¥½å•¦,é‚£å°±è®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ä»¤ç‰Œæ¡¶ç®—æ³•çš„å…·ä½“åº”ç”¨,å¼ºå¤§çš„guavaåŒ…çš„RateLimiterå·²ç»å®ç°äº†é™æµ,ä½¿ç”¨çš„æ˜¯ä»¤ç‰Œæ¡¶ç®—æ³•,å¹¶ä¸”å¯ä»¥å…è®¸ä¸€å®šç¨‹åº¦çš„è¯·æ±‚æ¿€å¢,çœ‹èµ·æ¥æ˜¯éå¸¸å¥½çš„ä¸œè¥¿~ç®€å•æ¥è¯´,çœ‹æ³¨é‡Šä¸Šæ¥è¯´,æ˜¯é€šè¿‡æ—¶é—´çš„æ¢ç®—æ¥ç­‰ä»·äºä»¤ç‰Œçš„å­˜å‚¨çš„,å…·ä½“çš„å®ç°æ–¹æ³•,çœ‹å…·ä½“çš„ä»£ç å®ç°å§~ /* * Copyright (C) 2012 The Guava Authors * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at å±Œå±Œçš„ï¼Œå…ˆè¯´æ˜ä¸€ä¸‹æ˜¯åŸºäºApache2çš„å“¦ï½ * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.common.util.concurrent; import com.google.common.annotations.Beta; import com.google.common.annotations.VisibleForTesting; import com.google.common.base.Preconditions; import com.google.common.base.Ticker; import java.util.concurrent.TimeUnit; import javax.annotation.concurrent.ThreadSafe; /** * A rate limiter. Conceptually, a rate limiter distributes permits at a * configurable rate. Each {@link #acquire()} blocks if necessary until a permit is * available, and then takes it. Once acquired, permits need not be released. å­—é¢æ„æ€ä¸Šæ¥è¯´ï¼ŒrateLimiterå½“ç„¶æ˜¯æŒ‰ç…§ä¸€ä¸ªç»™å®šçš„é€Ÿç‡æ¥è¿›è¡Œæ´¾å‘ä»¤ç‰Œå•¦ï½ æ‰§è¡Œacquire()æ–¹æ³•ï¼Œä¼šä¸€ç›´é˜»å¡ï¼Œç›´åˆ°æœ‰ä¸€ä¸ªä»¤ç‰Œæ˜¯å¯ç”¨çš„ï¼Œç„¶åè·å¾—è¿™ä¸ªä»¤ç‰Œï¼Œä¸€æ—¦ä»¤ç‰Œè¢«è·å¾—! ä»¤ç‰Œæ˜¯ä¸éœ€è¦è¢« `é‡Šæ”¾` çš„! * Rate limiters are often used to restrict the rate at which some * physical or logical resource is accessed. This is in contrast to {@link * java.util.concurrent.Semaphore} which restricts the number of concurrent * accesses instead of the rate (note though that concurrency and rate are closely related, * e.g. see Little's Law). RateLimiter å¸¸å¸¸è¢«ç”¨æ¥é™åˆ¶æŸäº›èµ„æºçš„è®¿é—®é€Ÿç‡ã€‚ è¿™å’ŒSemaphoreä¸åŒï¼ŒSemaphoreæ˜¯ç”¨æ¥é™åˆ¶ å¹¶å‘æ•°è€Œä¸æ˜¯é€Ÿç‡ï¼Œè¿™ä¸¤è€…è¿˜æ˜¯æœ‰ä¸åŒçš„ã€‚ * A {@code RateLimiter} is defined primarily by the rate at which permits * are issued. Absent additional configuration, permits will be distributed at a * fixed rate, defined in terms of permits per second. Permits will be distributed * smoothly, with the delay between individual permits being adjusted to ensure * that the configured rate is maintained. å¦‚æœæ²¡æœ‰é¢å¤–çš„é…ç½®ï¼Œä»¤ç‰Œä¼šä»¥å›ºå®šçš„é€Ÿç‡æ´¾å‘ï¼Œè¿™ä¸ªé€Ÿç‡ä»¥æ¯ç§’ä¸ºå•ä½è®¡ç®—ã€‚ ä»¤ç‰Œå°†ä¼šä»¥å¹³æ»‘çš„é€Ÿç‡æ´¾å‘ï¼Œå•ä½ä»¤ç‰Œä¹‹é—´çš„é—´éš”ä¼šè¢«è‰¯å¥½è°ƒé…ä»¥ä¿éšœä¹‹å‰è®¾å®šå¥½çš„é€Ÿç‡ã€‚ * * It is possible to configure a {@code RateLimiter} to have a warmup * period during which time the permits issued each second steadily increases until * it hits the stable rate. é€šè¿‡é…ç½®ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ä¸€ä¸ªé¢„çƒ­çš„é˜¶æ®µï¼Œåœ¨è¿™ä¸ªé˜¶æ®µä¸­æ¯ç§’åˆ†å‘çš„ä»¤ç‰Œæ•°å°†ä¼šé€’å¢ç›´åˆ°è¾¾åˆ°è¾¹ç•Œå€¼ä¸ºæ­¢ * * As an example, imagine that we have a list of tasks to execute, but we don't want to * submit more than 2 per second: ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œæœ‰ä¸€ä¸ªä»»åŠ¡é˜Ÿåˆ—éœ€è¦æ‰§è¡Œï¼Œä½†æ˜¯æˆ‘ä»¬ä¸æƒ³æ¯ç§’åŒæ—¶æ‰§è¡Œçš„ä»»åŠ¡è¶…è¿‡2ä¸ªï¼Œé‚£ä¹ˆå¯ä»¥è¿™æ ·å†™ * {@code * final RateLimiter rateLimiter = RateLimiter.create(2.0); // rate is \"2 permits per second\" * void submitTasks(List tasks, Executor executor) { * for (Runnable task : tasks) { * rateLimiter.acquire(); // may wait * executor.execute(task); * } * } *} * * As another example, imagine that we produce a stream of data, and we want to cap it * at 5kb per second. This could be accomplished by requiring a permit per byte, and specifying * a rate of 5000 permits per second: å¦ä¸€ä¸ªä¾‹å­å°±æ˜¯ï¼Œæƒ³è±¡ä¸€ä¸‹æ­£åœ¨å¤„ç†ä¸€ä¸ªæ•°æ®æµï¼Œç„¶åæˆ‘ä»¬æƒ³æ¯ç§’å¤„ç†5kbã€‚è¿™é‡Œçš„å¤„ç†æ–¹å¼ï¼Œä¸ºæ¯ä¸ªbyteåˆ†é…ä¸€ä¸ªä»¤ç‰Œï¼Œ å¹¶ä¸”æŒ‡å®šæ¯ç§’æœ‰5000ä¸ªä»¤ç‰Œã€‚ * {@code * final RateLimiter rateLimiter = RateLimiter.create(5000.0); // rate = 5000 permits per second * void submitPacket(byte[] packet) { * rateLimiter.acquire(packet.length); * networkService.send(packet); * } *} * * It is important to note that the number of permits requested never * affect the throttling of the request itself (an invocation to {@code acquire(1)} * and an invocation to {@code acquire(1000)} will result in exactly the same throttling, if any), * but it affects the throttling of the next request. I.e., if an expensive task * arrives at an idle RateLimiter, it will be granted immediately, but it is the next * request that will experience extra throttling, thus paying for the cost of the expensive * task. ä½œè€…æåˆ°äº†å¾ˆé‡è¦çš„ä¸€ç‚¹ï¼Œå½“å‰è¯·æ±‚çš„ä»¤ç‰Œæ•°é‡å¹¶ä¸ä¼šé˜»æ­¢å½“å‰çš„è¯·æ±‚ï¼Œacquire(1)å’Œacquire(1000)ä¼šå¯¼è‡´ç›¸åŒçš„ç»“æœï¼Œ å¦‚æœå½“å‰çš„è¯·æ±‚æ¶ˆè€—äº†ç‰¹åˆ«å¤šçš„ä»¤ç‰Œï¼Œé‚£ä¹ˆæ˜¯ç”±â€œä¸‹ä¸€ä¸ªè¯·æ±‚\"æ¥å¿è¿˜å½“å‰è¿™ä¸ªè¯·æ±‚æ‰€è€—è´¹çš„ä»¤ç‰Œã€‚ è¿™é‡Œæœ‰ç‚¹ç»•ï¼Œå…·ä½“è¿˜æ˜¯çœ‹ä»£ç å§ * * Note: {@code RateLimiter} does not provide fairness guarantees. å—¯...è¿™å°±æ˜¯ä¸å…¬å¹³çš„ï¼Œå°±åƒè¿™ä¸ªä¸–ç•Œä¸€æ · =ã€‚= face and embrace it * * @author Dimitris Andreou * @since 13.0 */ // TODO(user): switch to nano precision. A natural unit of cost is \"bytes\", and a micro precision // would mean a maximum rate of \"1MB/s\", which might be small in some cases. @ThreadSafe @Beta // wowï¼Œ åŸæ¥è¿™ç©æ„è¿˜åªæ˜¯ä¸ªBetaç‰ˆæœ¬å‘€ï½ public abstract class RateLimiter { /* * How is the RateLimiter designed, and why? * * The primary feature of a RateLimiter is its \"stable rate\", the maximum rate that * is should allow at normal conditions. This is enforced by \"throttling\" incoming * requests as needed, i.e. compute, for an incoming request, the appropriate throttle time, * and make the calling thread wait as much. å¯¹äºRateLimiteræœ€ä¸»è¦çš„ç‰¹æ€§å°±æ˜¯â€œç¨³å®šçš„é€Ÿç‡â€ï¼Œåœ¨é€šå¸¸æƒ…å†µä¸‹ï¼Œå…è®¸ä»¥æœ€é«˜çš„é€Ÿç‡è¿›è¡Œè¿ä½œã€‚ åé¢çš„ä¸çŸ¥é“æ€ä¹ˆç¿»è¯‘ * * The simplest way to maintain a rate of QPS is to keep the timestamp of the last * granted request, and ensure that (1/QPS) seconds have elapsed since then. For example, * for a rate of QPS=5 (5 tokens per second), if we ensure that a request isn't granted * earlier than 200ms after the the last one, then we achieve the intended rate. * If a request comes and the last request was granted only 100ms ago, then we wait for * another 100ms. At this rate, serving 15 fresh permits (i.e. for an acquire(15) request) * naturally takes 3 seconds. æœ€ç®€å•çš„æ§åˆ¶QPSçš„åŠæ³•,å°±æ˜¯æ§åˆ¶æ—¶é—´æˆ³å˜›,åªè¦ä¿è¯è‡ªä»ä¸Šä¸€æ¬¡å‘é€ä»¤ç‰Œåˆ°ç°åœ¨å·²ç»ç»è¿‡äº†(1/QPS)ç§’å³å¯,é‚£ä¹ˆ è¿™æ ·å°±ä¿è¯äº†åŸºæœ¬çš„QPS. * It is important to realize that such a RateLimiter has a very superficial memory * of the past: it only remembers the last request. What if the RateLimiter was unused for * a long period of time, then a request arrived and was immediately granted? * This RateLimiter would immediately forget about that past underutilization. This may * result in either underutilization or overflow, depending on the real world consequences * of not using the expected rate. ä¸Šè¿°åšæ³•è™½ç„¶ç®€å•ç²—æš´,ä½†æ˜¯æœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„ä¸€ç‚¹,å°±æ˜¯å®ƒâ€œå¯¹äºè¿‡å»çš„è®¤è¯†å¹¶ä¸å……åˆ†â€--å®ƒä»…è®°ä½äº†ä¸Šä¸€æ¬¡çš„è¯·æ±‚, å¦‚æœRateLimiterå¾ˆä¹…ä¸è¢«ä½¿ç”¨ï¼Œæ–°æ¥äº†ä¸€ä¸ªè¯·æ±‚,å¹¶ä¸”è¿™ä¸ªè¯·æ±‚å¾ˆå¿«ä¼šè·å¾—æŒ‡ä»¤,é‚£ä¹ˆå®ƒæœºä¼š\"å¿˜è®°\"æ‰ä¹‹å‰çš„ä½ä½¿ç”¨ç‡, è¿™å¯èƒ½ä¼šå¯¼è‡´ä¸€äº›é—®é¢˜,å…·ä½“å–å†³äºå…·ä½“çš„åœºæ™¯. * Past underutilization could mean that excess resources are available. Then, the RateLimiter * should speed up for a while, to take advantage of these resources. This is important * when the rate is applied to networking (limiting bandwidth), where past underutilization * typically translates to \"almost empty buffers\", which can be filled immediately. è¿‡å»çš„ä½ä½¿ç”¨ç‡æ„å‘³ç€æœ‰å‰©ä½™çš„å¯ç”¨èµ„æº,æ‰€ä»¥RateLimiterå¯ä»¥æé€Ÿ(??? è¿™é‡Œä¸æ¸…æ¥šåº”è¯¥æ€ä¹ˆç¿»è¯‘)æ¥ä½¿ç”¨è¿™äº›èµ„æº, * On the other hand, past underutilization could mean that \"the server responsible for * handling the request has become less ready for future requests\", i.e. its caches become * stale, and requests become more likely to trigger expensive operations (a more extreme * case of this example is when a server has just booted, and it is mostly busy with getting * itself up to speed). å¦ä¸ªæ–¹é¢è®²,ä½ä½¿ç”¨ç‡æ„å‘³ç€å¤„ç†è¿™äº›è¯·æ±‚çš„æœåŠ¡æœ‰å¯èƒ½è¿˜æ²¡æœ‰å‡†å¤‡å¥½ä½¿ç”¨è¿™äº›è¯·æ±‚,æ¯”å¦‚è¯´å½“æœåŠ¡ä½¿ç”¨åˆ°cacheæ—¶, é‚£ä¹ˆåœ¨é•¿æ—¶é—´çš„é—´éš”ä¹‹åçš„çªç„¶è¯·æ±‚,æœ‰å¯èƒ½ä¼šé€ æˆcacheçš„å¤§é‡miss,æ›´æç«¯çš„è¯·æ±‚æ˜¯å½“æœåŠ¡åˆšå¯åŠ¨æ—¶. * To deal with such scenarios, we add an extra dimension, that of \"past underutilization\", * modeled by \"storedPermits\" variable. This variable is zero when there is no * underutilization, and it can grow up to maxStoredPermits, for sufficiently large * underutilization. So, the requested permits, by an invocation acquire(permits), * are served from: * - stored permits (if available) * - fresh permits (for any remaining permits) ä½œè€…ä½¿ç”¨äº†ä¸€ä¸ªé¢å¤–çš„ç»´åº¦æ¥æè¿°è¿‡å»çš„ä½ä½¿ç”¨ç‡, storedPermits å½“æ–°è¯·æ±‚ä»¤ç‰Œæ—¶,ä»¤ç‰Œä»stored permitså’Œfresh permitsä¸¤ä¸ªåœ°æ–¹è·å¾— * How this works is best explained with an example: * * For a RateLimiter that produces 1 token per second, every second * that goes by with the RateLimiter being unused, we increase storedPermits by 1. * Say we leave the RateLimiter unused for 10 seconds (i.e., we expected a request at time * X, but we are at time X + 10 seconds before a request actually arrives; this is * also related to the point made in the last paragraph), thus storedPermits * becomes 10.0 (assuming maxStoredPermits >= 10.0). At that point, a request of acquire(3) * arrives. We serve this request out of storedPermits, and reduce that to 7.0 (how this is * translated to throttling time is discussed later). Immediately after, assume that an * acquire(10) request arriving. We serve the request partly from storedPermits, * using all the remaining 7.0 permits, and the remaining 3.0, we serve them by fresh permits * produced by the rate limiter. storedPermitså…¶å®æ˜¯ä¸€ä¸ªé¢„å¤‡çš„åº“å­˜çš„æ„æ€,å¦‚æœå…¶ä¸­è¿˜æœ‰ä»¤ç‰Œé¢„å­˜,å°±ç›´æ¥å–,å¦‚æœä¸å¤Ÿçš„è¯,ä¸è¶³çš„éƒ¨åˆ†ç”¨fresh permitsæ¥å¼¥è¡¥ å½“ç„¶,ä½œè€…å°†è¿™äº›è¡¥å¿çš„å…¬å¼éƒ½è½¬æ¢ä¸ºæ—¶é—´ä¸Šçš„è®¡ç®—,è®¡ç®—æ–¹å¼åé¢å†çœ‹ * We already know how much time it takes to serve 3 fresh permits: if the rate is * \"1 token per second\", then this will take 3 seconds. But what does it mean to serve 7 * stored permits? As explained above, there is no unique answer. If we are primarily * interested to deal with underutilization, then we want stored permits to be given out * /faster/ than fresh ones, because underutilization = free resources for the taking. * If we are primarily interested to deal with overflow, then stored permits could * be given out /slower/ than fresh ones. Thus, we require a (different in each case) * function that translates storedPermits to throtting time. å…¶å®æ–°è¯·æ±‚3ä¸ªä»¤ç‰Œçš„æ—¶é—´æ˜¯å®¹æ˜“è®¡ç®—çš„,é‚£ä¹ˆé—®é¢˜å°±åœ¨äºå¦‚ä½•è¡¨ç¤º\"æä¾›7ä¸ªstored permits\"? ä½œè€…è¯´, 1:å¦‚æœè¦åº”å¯¹çš„ä½ä½¿ç”¨ç‡,é‚£ä¹ˆåœ¨æä¾›stored permitsçš„æ—¶å€™å°±éœ€è¦æ¯”fresh permitsè¦\"å¿«\"ä¸€äº›,å› ä¸º å®é™…ä¸Šstored permitså°±æ„å‘³ç€æ˜¯\"é—²ç½®çš„èµ„æº\", 2:å¦‚æœè¦åº”å¯¹çš„æ˜¯è¿‡é«˜ä½¿ç”¨ç‡,é‚£ä¹ˆstored permitså°±éœ€è¦æ…¢ä¸€äº› æ‰€ä»¥ä½œè€…requireäº†ä¸€ä¸ªfunctionæ¥å°†storePermitsè½¬åŒ–ä¸ºthrotting time OK,ä¸‹é¢å°±æ˜¯ç®—æ³•æè¿°,çœ‹ä¸æ‡‚,å…ˆçœ‹ä»£ç ~ * This role is played by storedPermitsToWaitTime(double storedPermits, double permitsToTake). * The underlying model is a continuous function mapping storedPermits * (from 0.0 to maxStoredPermits) onto the 1/rate (i.e. intervals) that is effective at the given * storedPermits. \"storedPermits\" essentially measure unused time; we spend unused time * buying/storing permits. Rate is \"permits / time\", thus \"1 / rate = time / permits\". * Thus, \"1/rate\" (time / permits) times \"permits\" gives time, i.e., integrals on this * function (which is what storedPermitsToWaitTime() computes) correspond to minimum intervals * between subsequent requests, for the specified number of requested permits. * * Here is an example of storedPermitsToWaitTime: * If storedPermits == 10.0, and we want 3 permits, we take them from storedPermits, * reducing them to 7.0, and compute the throttling for these as a call to * storedPermitsToWaitTime(storedPermits = 10.0, permitsToTake = 3.0), which will * evaluate the integral of the function from 7.0 to 10.0. * * Using integrals guarantees that the effect of a single acquire(3) is equivalent * to { acquire(1); acquire(1); acquire(1); }, or { acquire(2); acquire(1); }, etc, * since the integral of the function in [7.0, 10.0] is equivalent to the sum of the * integrals of [7.0, 8.0], [8.0, 9.0], [9.0, 10.0] (and so on), no matter * what the function is. This guarantees that we handle correctly requests of varying weight * (permits), /no matter/ what the actual function is - so we can tweak the latter freely. * (The only requirement, obviously, is that we can compute its integrals). * * Note well that if, for this function, we chose a horizontal line, at height of exactly * (1/QPS), then the effect of the function is non-existent: we serve storedPermits at * exactly the same cost as fresh ones (1/QPS is the cost for each). We use this trick later. * * If we pick a function that goes /below/ that horizontal line, it means that we reduce * the area of the function, thus time. Thus, the RateLimiter becomes /faster/ after a * period of underutilization. If, on the other hand, we pick a function that * goes /above/ that horizontal line, then it means that the area (time) is increased, * thus storedPermits are more costly than fresh permits, thus the RateLimiter becomes * /slower/ after a period of underutilization. * * Last, but not least: consider a RateLimiter with rate of 1 permit per second, currently * completely unused, and an expensive acquire(100) request comes. It would be nonsensical * to just wait for 100 seconds, and /then/ start the actual task. Why wait without doing * anything? A much better approach is to /allow/ the request right away (as if it was an * acquire(1) request instead), and postpone /subsequent/ requests as needed. In this version, * we allow starting the task immediately, and postpone by 100 seconds future requests, * thus we allow for work to get done in the meantime instead of waiting idly. * * This has important consequences: it means that the RateLimiter doesn't remember the time * of the _last_ request, but it remembers the (expected) time of the _next_ request. This * also enables us to tell immediately (see tryAcquire(timeout)) whether a particular * timeout is enough to get us to the point of the next scheduling time, since we always * maintain that. And what we mean by \"an unused RateLimiter\" is also defined by that * notion: when we observe that the \"expected arrival time of the next request\" is actually * in the past, then the difference (now - past) is the amount of time that the RateLimiter * was formally unused, and it is that amount of time which we translate to storedPermits. * (We increase storedPermits with the amount of permits that would have been produced * in that idle time). So, if rate == 1 permit per second, and arrivals come exactly * one second after the previous, then storedPermits is _never_ increased -- we would only * increase it for arrivals _later_ than the expected one second. */ /** * Creates a {@code RateLimiter} with the specified stable throughput, given as * \"permits per second\" (commonly referred to as QPS, queries per second). * * The returned {@code RateLimiter} ensures that on average no more than {@code * permitsPerSecond} are issued during any given second, with sustained requests * being smoothly spread over each second. When the incoming request rate exceeds * {@code permitsPerSecond} the rate limiter will release one permit every {@code * (1.0 / permitsPerSecond)} seconds. When the rate limiter is unused, * bursts of up to {@code permitsPerSecond} permits will be allowed, with subsequent * requests being smoothly limited at the stable rate of {@code permitsPerSecond}. RateLimiterä¿è¯äº† * @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in * how many permits become available per second. */ // TODO(user): \"This is equivalent to // {@code createWithCapacity(permitsPerSecond, 1, TimeUnit.SECONDS)}\". public static RateLimiter create(double permitsPerSecond) { /* * The default RateLimiter configuration can save the unused permits of up to one second. * This is to avoid unnecessary stalls in situations like this: A RateLimiter of 1qps, * and 4 threads, all calling acquire() at these moments: * * T0 at 0 seconds * T1 at 1.05 seconds * T2 at 2 seconds * T3 at 3 seconds * * Due to the slight delay of T1, T2 would have to sleep till 2.05 seconds, * and T3 would also have to sleep till 3.05 seconds. */ return create(SleepingTicker.SYSTEM_TICKER, permitsPerSecond); } @VisibleForTesting static RateLimiter create(SleepingTicker ticker, double permitsPerSecond) { RateLimiter rateLimiter = new Bursty(ticker, 1.0 /* maxBurstSeconds */); rateLimiter.setRate(permitsPerSecond); return rateLimiter; } /** * Creates a {@code RateLimiter} with the specified stable throughput, given as * \"permits per second\" (commonly referred to as QPS, queries per second), and a * warmup period, during which the {@code RateLimiter} smoothly ramps up its rate, * until it reaches its maximum rate at the end of the period (as long as there are enough * requests to saturate it). Similarly, if the {@code RateLimiter} is left unused for * a duration of {@code warmupPeriod}, it will gradually return to its \"cold\" state, * i.e. it will go through the same warming up process as when it was first created. * * The returned {@code RateLimiter} is intended for cases where the resource that actually * fulfills the requests (e.g., a remote server) needs \"warmup\" time, rather than * being immediately accessed at the stable (maximum) rate. * * The returned {@code RateLimiter} starts in a \"cold\" state (i.e. the warmup period * will follow), and if it is left unused for long enough, it will return to that state. * * @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in * how many permits become available per second * @param warmupPeriod the duration of the period where the {@code RateLimiter} ramps up its * rate, before reaching its stable (maximum) rate * @param unit the time unit of the warmupPeriod argument */ public static RateLimiter create(double permitsPerSecond, long warmupPeriod, TimeUnit unit) { return create(SleepingTicker.SYSTEM_TICKER, permitsPerSecond, warmupPeriod, unit); } @VisibleForTesting static RateLimiter create( SleepingTicker ticker, double permitsPerSecond, long warmupPeriod, TimeUnit unit) { RateLimiter rateLimiter = new WarmingUp(ticker, warmupPeriod, unit); rateLimiter.setRate(permitsPerSecond); return rateLimiter; } @VisibleForTesting static RateLimiter createWithCapacity( SleepingTicker ticker, double permitsPerSecond, long maxBurstBuildup, TimeUnit unit) { double maxBurstSeconds = unit.toNanos(maxBurstBuildup) / 1E+9; Bursty rateLimiter = new Bursty(ticker, maxBurstSeconds); rateLimiter.setRate(permitsPerSecond); return rateLimiter; } /** * The underlying timer; used both to measure elapsed time and sleep as necessary. A separate * object to facilitate testing. */ private final SleepingTicker ticker; /** * The timestamp when the RateLimiter was created; used to avoid possible overflow/time-wrapping * errors. */ private final long offsetNanos; /** * The currently stored permits. */ double storedPermits; /** * The maximum number of stored permits. */ double maxPermits; /** * The interval between two unit requests, at our stable rate. E.g., a stable rate of 5 permits * per second has a stable interval of 200ms. */ volatile double stableIntervalMicros; private final Object mutex = new Object(); /** * The time when the next request (no matter its size) will be granted. After granting a request, * this is pushed further in the future. Large requests push this further than small requests. */ private long nextFreeTicketMicros = 0L; // could be either in the past or future private RateLimiter(SleepingTicker ticker) { this.ticker = ticker; this.offsetNanos = ticker.read(); } /** * Updates the stable rate of this {@code RateLimiter}, that is, the * {@code permitsPerSecond} argument provided in the factory method that * constructed the {@code RateLimiter}. Currently throttled threads will not * be awakened as a result of this invocation, thus they do not observe the new rate; * only subsequent requests will. * * Note though that, since each request repays (by waiting, if necessary) the cost * of the previous request, this means that the very next request * after an invocation to {@code setRate} will not be affected by the new rate; * it will pay the cost of the previous request, which is in terms of the previous rate. * * The behavior of the {@code RateLimiter} is not modified in any other way, * e.g. if the {@code RateLimiter} was configured with a warmup period of 20 seconds, * it still has a warmup period of 20 seconds after this method invocation. * * @param permitsPerSecond the new stable rate of this {@code RateLimiter}. */ public final void setRate(double permitsPerSecond) { Preconditions.checkArgument(permitsPerSecond > 0.0 && !Double.isNaN(permitsPerSecond), \"rate must be positive\"); synchronized (mutex) { resync(readSafeMicros()); double stableIntervalMicros = TimeUnit.SECONDS.toMicros(1L) / permitsPerSecond; this.stableIntervalMicros = stableIntervalMicros; doSetRate(permitsPerSecond, stableIntervalMicros); } } abstract void doSetRate(double permitsPerSecond, double stableIntervalMicros); /** * Returns the stable rate (as {@code permits per seconds}) with which this * {@code RateLimiter} is configured with. The initial value of this is the same as * the {@code permitsPerSecond} argument passed in the factory method that produced * this {@code RateLimiter}, and it is only updated after invocations * to {@linkplain #setRate}. */ public final double getRate() { return TimeUnit.SECONDS.toMicros(1L) / stableIntervalMicros; } /** * Acquires a permit from this {@code RateLimiter}, blocking until the request can be granted. * * This method is equivalent to {@code acquire(1)}. */ public void acquire() { acquire(1); } /** * Acquires the given number of permits from this {@code RateLimiter}, blocking until the * request be granted. * * @param permits the number of permits to acquire */ public void acquire(int permits) { checkPermits(permits); long microsToWait; synchronized (mutex) { microsToWait = reserveNextTicket(permits, readSafeMicros()); } ticker.sleepMicrosUninterruptibly(microsToWait); } /** * Acquires a permit from this {@code RateLimiter} if it can be obtained * without exceeding the specified {@code timeout}, or returns {@code false} * immediately (without waiting) if the permit would not have been granted * before the timeout expired. * * This method is equivalent to {@code tryAcquire(1, timeout, unit)}. * * @param timeout the maximum time to wait for the permit * @param unit the time unit of the timeout argument * @return {@code true} if the permit was acquired, {@code false} otherwise */ public boolean tryAcquire(long timeout, TimeUnit unit) { return tryAcquire(1, timeout, unit); } /** * Acquires permits from this {@link RateLimiter} if it can be acquired immediately without delay. * * * This method is equivalent to {@code tryAcquire(permits, 0, anyUnit)}. * * @param permits the number of permits to acquire * @return {@code true} if the permits were acquired, {@code false} otherwise * @since 14.0 */ public boolean tryAcquire(int permits) { return tryAcquire(permits, 0, TimeUnit.MICROSECONDS); } /** * Acquires a permit from this {@link RateLimiter} if it can be acquired immediately without * delay. * * * This method is equivalent to {@code tryAcquire(1)}. * * @return {@code true} if the permit was acquired, {@code false} otherwise * @since 14.0 */ public boolean tryAcquire() { return tryAcquire(1, 0, TimeUnit.MICROSECONDS); } /** * Acquires the given number of permits from this {@code RateLimiter} if it can be obtained * without exceeding the specified {@code timeout}, or returns {@code false} * immediately (without waiting) if the permits would not have been granted * before the timeout expired. * * @param permits the number of permits to acquire * @param timeout the maximum time to wait for the permits * @param unit the time unit of the timeout argument * @return {@code true} if the permits were acquired, {@code false} otherwise */ public boolean tryAcquire(int permits, long timeout, TimeUnit unit) { long timeoutMicros = unit.toMicros(timeout); checkPermits(permits); long microsToWait; synchronized (mutex) { long nowMicros = readSafeMicros(); if (nextFreeTicketMicros > nowMicros + timeoutMicros) { return false; } else { microsToWait = reserveNextTicket(permits, nowMicros); } } ticker.sleepMicrosUninterruptibly(microsToWait); return true; } private static void checkPermits(int permits) { Preconditions.checkArgument(permits > 0, \"Requested permits must be positive\"); } /** * Reserves next ticket and returns the wait time that the caller must wait for. */ private long reserveNextTicket(double requiredPermits, long nowMicros) { resync(nowMicros); long microsToNextFreeTicket = nextFreeTicketMicros - nowMicros; double storedPermitsToSpend = Math.min(requiredPermits, this.storedPermits); double freshPermits = requiredPermits - storedPermitsToSpend; long waitMicros = storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend) + (long) (freshPermits * stableIntervalMicros); this.nextFreeTicketMicros = nextFreeTicketMicros + waitMicros; this.storedPermits -= storedPermitsToSpend; return microsToNextFreeTicket; } /** * Translates a specified portion of our currently stored permits which we want to * spend/acquire, into a throttling time. Conceptually, this evaluates the integral * of the underlying function we use, for the range of * [(storedPermits - permitsToTake), storedPermits]. * * This always holds: {@code 0","categories":[{"name":"Java","slug":"Java","permalink":"http://kevingeek.github.io/categories/Java/"}],"tags":[{"name":"RateLimiter","slug":"RateLimiter","permalink":"http://kevingeek.github.io/tags/RateLimiter/"},{"name":"Server","slug":"Server","permalink":"http://kevingeek.github.io/tags/Server/"}]},{"title":"HashMapæºç è§£æ","slug":"HashMapæºç è§£æ","date":"2016-08-02T09:35:00.000Z","updated":"2020-04-09T04:19:33.057Z","comments":true,"path":"2016/08/02/HashMapæºç è§£æ/","link":"","permalink":"http://kevingeek.github.io/2016/08/02/HashMapæºç è§£æ/","excerpt":"ä¸€å‘æœªå¹³ï¼Œä¸€å‘åˆèµ·ï¼Œä»Šå¤©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹HashMapHashMapç»§æ‰¿è‡ªAbstractMapï¼Œå®ç°Mapæ¥å£ï¼Œæ˜¯ä¸€ä¸ªæ ‡å‡†çš„Mapå®ç°","text":"ä¸€å‘æœªå¹³ï¼Œä¸€å‘åˆèµ·ï¼Œä»Šå¤©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹HashMapHashMapç»§æ‰¿è‡ªAbstractMapï¼Œå®ç°Mapæ¥å£ï¼Œæ˜¯ä¸€ä¸ªæ ‡å‡†çš„Mapå®ç° åˆå§‹åŒ–HashMapä¸€ä¸ªå‚æ•°ä¸ºåˆå§‹å¤§å°å€¼ï¼Œ ä¸€ä¸ªä¸ºå¡«å……å› å­ï¼Œå¯ä»¥å‘ç°ï¼Œåœ¨æ„é€ å‡½æ•°é‡Œé¢é™¤äº†åŸºæœ¬çš„èµ‹å€¼å¤–ï¼Œå¹¶æ²¡æœ‰åšæ•°æ®åˆå§‹åŒ–çš„æ“ä½œï¼Œè€Œé‚£ä¸ªinit()åˆ™æ˜¯ä¸ªå¹Œå­= =ï¼Œæ­£å®—çš„å•¥ä¹Ÿæ²¡å¹²å•Š /** * Constructs an empty HashMap with the specified initial * capacity and load factor. * * @param initialCapacity åˆå§‹å¤§å° * @param loadFactor å¡«å……å› å­ * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity < 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity > MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor = toSize int capacity = roundUpToPowerOf2(toSize); //è¿™é‡Œå¾ˆç²¾å¦™çš„è®¾ç½®äº†capacity threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); table = new Entry[capacity]; initHashSeedAsNeeded(capacity); // è®¾ç½®å“ˆå¸Œç§å­ We defer initialization until we really need it. } åœ¨roundUpTOPowerOf2æ–¹æ³•é‡Œé¢è¿”å›çš„æ˜¯2çš„Næ¬¡æ–¹ï¼Œå‡è®¾ä¸ºXï¼ŒNå–ä½¿å¾—Xå¤§äºtoSizeçš„é›†åˆä¸­çš„æœ€å°å€¼ï¼Œä¾‹å¦‚ roundUpToPowerOf2(31) = 32 roundUpToPowerOf2(60) = 64 æ·»åŠ å…ƒç´ puté‡å¤´æˆputæ–¹æ³•ï¼Œæ·»åŠ å…ƒç´ å¦‚ä¸Šå›¾æ‰€è¯´ï¼ŒWe defer initialization until we really need it., é‚£ä¹ˆå¾ˆå®¹æ˜“è”æƒ³åˆ°ï¼ŒinflateTableå‡½æ•°å…¶å®æ˜¯åœ¨putæ–¹æ³•é‡Œé¢ä¼šè¢«è°ƒç”¨ï¼Œå› ä¸ºè¿™æ—¶å€™æ‰really need itå˜›ã€‚ /** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with key, or * null if there was no mapping for key. * (A null return can also indicate that the map * previously associated null with key.) */ public V put(K key, V value) { if (table == EMPTY_TABLE) { inflateTable(threshold); //å¦‚æœæ˜¯ç©ºMapçš„è¯ï¼Œå°±åšåˆå§‹åŒ–æ“ä½œ } if (key == null) return putForNullKey(value); // è¿™é‡Œå¯¹nullå€¼åšäº†å•ç‹¬çš„å¤„ç† int hash = hash(key); int i = indexFor(hash, table.length); // è¿™ä¸ªindexForå·§å¦™åˆ©ç”¨äº†tableçš„Length for (Entry e = table[i]; e != null; e = e.next) { Object k; // å¦‚æœhashå€¼ä¸€æ ·(é”®å†²çª)ï¼Œå¹¶keyæ˜¯çœŸçš„ä¸€æ ·çš„è¯ // åˆ™ç”¨æ–°çš„valueè¦†ç›–è€valueï¼Œè¿”å›è€value if (e.hash == hash && ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; // å¦‚æœæ²¡æœ‰å‡ºç°keyå®Œå…¨ç›¸åŒçš„æƒ…å†µ(ä¾‹å¦‚hashå€¼ä¸åŒï¼Œæˆ–è€…åªæ˜¯hashå†²çªäº†) // æ·»åŠ æ–°çš„Entryï¼Œè¿™ä¸ªaddEntryçš„éƒ¨åˆ†éœ€è¦å¥½å¥½çœ‹çœ‹ addEntry(hash, key, value, i); return null; } put-indexForç”±ç»™å®šçš„hashå€¼ï¼Œè¿”å›å¯¹åº”çš„å“ˆå¸Œæ¡¶ä¸‹æ ‡ç›´æ¥ä½¿ç”¨length-1å’Œhashå€¼è¿›è¡Œä¸æ“ä½œï¼Œ å› ä¸ºlengthæ˜¯2çš„æ¬¡æ–¹ï¼Œæ‰€ä»¥length -1æ‰€æœ‰ä½ä¸Šéƒ½æ˜¯1ï¼Œç›´æ¥ä¸æ“ä½œå¯ä»¥è¿…é€Ÿè·å¾—å¯¹åº”çš„Indexå€¼ /** * Returns index for hash code h. */ static int indexFor(int h, int length) { // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\"; return h & (length-1); } put-addEntryç»™å°†æ•°æ®æ·»åŠ åˆ°tableä¸­ï¼Œå¦‚æœæœ‰å¿…è¦ï¼Œnewä¸€ä¸ªæ–°çš„table :) /** * Adds a new entry with the specified key, value and hash code to * the specified bucket. It is the responsibility of this * method to resize the table if appropriate. * * Subclass overrides this to alter the behavior of put method. */ void addEntry(int hash, K key, V value, int bucketIndex) { // å¦‚æœå½“å‰Mapçš„sizeå·²ç»å¤§äºé˜ˆå€¼ï¼Œå¹¶ä¸”å½“å‰è¿™ä¸ªå“ˆç³»æ¡¶ä¹Ÿå·²ç»è¢«å®ä¾‹åŒ–è¿‡çš„è¯ // åˆ™éœ€è¦è¿›è¡Œé•¿åº¦å¡«å……ï¼Œæ–°é•¿åº¦ä¸ºåŸé•¿åº¦çš„2å€ if ((size >= threshold) && (null != table[bucketIndex])) { resize(2 * table.length); // resizeçš„å¼€é”€æ¯”è¾ƒå¤§ï¼Œæˆ‘ä»¬ä¸€ä¼šçœ‹ä¸€ä¸‹ hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length);// è·å¾—å“ˆå¸Œæ¡¶çš„ä¸‹æ ‡ } createEntry(hash, key, value, bucketIndex); } put-addEntry-resizeresizeï¼Œå¯¹tableè¿›è¡Œæ‰©å®¹éœ€è¦å®Œæˆå‡ ä¸ªæ­¥éª¤ å¼€è¾Ÿæ–°æ•°ç»„ å°†oldTableä¸­çš„å€¼å…¨éƒ¨æ˜ å°„newTableä¸­ å¦‚æœæœ‰å¿…è¦çš„è¯ï¼Œé‡æ–°ç”ŸæˆhashSeed(è¿™å—æˆ‘æ²¡çœ‹æ‡‚ï¼Œæ¬¢è¿å¤§ç¥æŒ‡æ•™) /** * Rehashes the contents of this map into a new array with a * larger capacity. This method is called automatically when the * number of keys in this map reaches its threshold. * * If current capacity is MAXIMUM_CAPACITY, this method does not * resize the map, but sets threshold to Integer.MAX_VALUE. * This has the effect of preventing future calls. * * @param newCapacity the new capacity, MUST be a power of two; * must be greater than current capacity unless current * capacity is MAXIMUM_CAPACITY (in which case value * is irrelevant). */ void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); // è½¬ç§»å…ƒç´  table = newTable; //å°†tableçš„å¼•ç”¨æ›¿æ¢ threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); // æ›´æ–° thresholdï¼Œ MAXIMUM_CAPACITYçš„å€¼æ˜¯ 2^30 } put-addEntry-resize-transfertransferå€’æ˜¯æ„å¤–çš„ç®€å•ï¼Œç”±è€tableæ·»åŠ åˆ°æ–°tableï¼Œå¾ªç¯éå†ï¼Œå°†å€¼æ’å…¥å³å¯ /** * Transfers all entries from current table to newTable. */ void transfer(Entry[] newTable, boolean rehash) { int newCapacity = newTable.length; for (Entry e : table) { while(null != e) { Entry next = e.next; if (rehash) { e.hash = null == e.key ? 0 : hash(e.key); } int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; } } } put-addEntry-resize-initHashSeedAsNeededåˆå§‹åŒ–hashSeedè¿˜è®°å¾—é‚£å¥ We defer initialization until we really need it. å˜›ï¼Ÿ å‡ºå¤„æ¥è‡ªè¿™é‡Œäº†ï¼Œswitchingçš„å–å€¼ä¸æ˜¯ç‰¹åˆ«æ˜ç™½ /** * Initialize the hashing mask value. We defer initialization until we * really need it. */ final boolean initHashSeedAsNeeded(int capacity) { boolean currentAltHashing = hashSeed != 0; boolean useAltHashing = sun.misc.VM.isBooted() && (capacity >= Holder.ALTERNATIVE_HASHING_THRESHOLD); boolean switching = currentAltHashing ^ useAltHashing; if (switching) { hashSeed = useAltHashing ? sun.misc.Hashing.randomHashSeed(this) : 0; } return switching; } put-addEntry-createEntryæœ€åº•å±‚çš„æ·»åŠ å…ƒç´ çš„æ–¹æ³•ï¼Œæ˜¯ä¸æ˜¯ç®€å•å¾—äº®çäº†çœ¼=ã€‚= å”¯ä¸€èƒ½å¹²ç‚¹æ´»çš„ä¹Ÿå°±åªæœ‰Entryçš„æ„é€ å‡½æ•°äº†ï¼Œä¸€èµ·çœ‹ä¸€ä¸‹ /** * Like addEntry except that this version is used when creating entries * as part of Map construction or \"pseudo-construction\" (cloning, * deserialization). This version needn't worry about resizing the table. * * Subclass overrides this to alter the behavior of HashMap(Map), * clone, and readObject. */ void createEntry(int hash, K key, V value, int bucketIndex) { Entry e = table[bucketIndex]; // è·å¾—å½“å‰å“ˆå¸Œæ¡¶çš„å®ä¾‹ table[bucketIndex] = new Entry(hash, key, value, e); // ç›´æ¥newä¸€ä¸ªEntryï¼Œç„¶åæ›¿æ¢æ‰åŸæœ‰çš„å“ˆç³»æ¡¶ï¼Œä½¿ç”¨é“¾è¡¨ç»“æ„ä¿å­˜åŸæ¥æ—§å€¼çš„å®ä¾‹ // ç›´æ¥ä½¿ç”¨å“ˆå¸Œæ¡¶æ‰¾åˆ°çš„åœ°ä¸€ä¸ªå€¼ï¼Œæ€»æ˜¯æœ€è¿‘æ’å…¥åˆ°è¿™ä¸ªå“ˆå¸Œæ¡¶çš„å€¼(æœ‰ä¸€ç‚¹æ—¶é—´å±€éƒ¨æ€§çš„æ„å‘³ï¼Ÿ) // å…·ä½“çœ‹Entryçš„åˆ†æ size++; //æ–°æ·»åŠ äº†ä¸€ä¸ªå…ƒç´ ï¼ŒsizeåŠ 1 } HashMap.EntryEntryæ˜¯HashMapå†…éƒ¨ç”¨æ¥å­˜å‚¨å…·ä½“æ•°æ®çš„å†…éƒ¨ç±»ï¼Œæ‰€æœ‰çš„æ•°æ®å­˜å‚¨åœ¨ä¸€ä¸ªEntry&lt;K,V&gt;ç±»å‹çš„æ•°ç»„ä¸­ï¼Œçœ‹ä¸€ä¸‹Entryçš„å®šä¹‰ static class Entry implements Map.Entry { final K key; V value; Entry next; int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry n) { value = v; next = n; // è¿™é‡Œå°†åŸæ¥åœ¨è¿™ä¸ªä½ç½®çš„valueä¿å­˜åœ¨äº†nexté‡Œé¢ï¼Œ // ä¹Ÿå°±æ˜¯newEntryæ€»æ˜¯æ·»åŠ åœ¨è¿™ä¸ªå“ˆå¸Œæ¡¶çš„é“¾è¡¨é¦–éƒ¨ key = k; hash = h; } public final K getKey() { return key; } public final V getValue() { return value; } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } // ä¸ºèŠ‚çœç¯‡å¹…ï¼Œæ­¤å¤„çœå»äº†ä¸€äº›å…³ç³»ä¸å¤§çš„æ–¹æ³•..... } éå†å…ƒç´ éå†HashMapæœ€å¿«çš„æ–¹æ³•æ˜¯ï¼Ÿ æ²¡é”™ï¼Œæ˜¯EntrySet() ç¥­å‡ºç¥å›¾å…ˆç¥­å‡ºè¿™å¼ ç¥å›¾ï¼Œæœ‰ä¸ªå°è±¡æˆ‘ä»¬å†å¾€ä¸‹çœ‹ HashMap |- table HashMap.EntryIterator | \\- next() / å†çœ‹ä»£ç çœ‹ä¸€ä¸‹ä»£ç ï¼ŒentrySet()çš„ç»“æ„éå¸¸ç®€å•ï¼Œæœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼Œä¸‹é¢çš„å‡½æ•° ä¸æ˜¯æ„é€ å‡½æ•° /** * Returns a {@link Set} view of the mappings contained in this map. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. If the map is modified * while an iteration over the set is in progress (except through * the iterator's own remove operation, or through the * setValue operation on a map entry returned by the * iterator) the results of the iteration are undefined. The set * supports element removal, which removes the corresponding * mapping from the map, via the Iterator.remove, * Set.remove, removeAll, retainAll and * clear operations. It does not support the * add or addAll operations. * * @return a set view of the mappings contained in this map */ public Set entrySet() { return entrySet0(); } private Set entrySet0() { Set es = entrySet; return es != null ? es : (entrySet = new EntrySet()); } çœ‹ä¸Šå»entrySetä¿å­˜äº†ä¸€ä»½æ•°æ®ï¼Œç„¶åè¿”å›çš„æ—¶å€™ç›´æ¥è¿”å›äº†æ•°æ®é›†åˆï¼Œç„¶è€Œè¿™é‡Œæœ‰ä¸€ä¸ªå¤§å‘ï¼Œå®é™…ä¸ŠEntrySetè¿œè¿œæ¯”è¿™ç‰›é€¼å¤ªå¤šäº†EntrySetæ˜¯ä½¿ç”¨iteratoræ¥è¿›è¡Œéå†ï¼Œè€Œiteratoræ‰€è°ƒç”¨çš„å†…å­˜ç©ºé—´æ°å¥½æ˜¯HashMapä¿å­˜çš„tableï¼ï¼ï¼ entrySetå…¶å®æ˜¯tableçš„å¦å¤–ä¸€ç§å±•ç°å½¢å¼ï¼Œtableæ”¹å˜ï¼ŒentrySetä¹Ÿæ”¹å˜ï¼Œåä¹‹äº¦ç„¶AkaReturns a view of the mappings contained in this map.The set is backed by the map, so changes to the map arereflected in the set, and vice-versa.çœ‹ä¸æ‡‚æ²¡å…³ç³»ï¼Œæˆ‘ä»¬æ…¢æ…¢åˆ†æ (ä¸ºäº†è¿æƒ¯æ€§ï¼Œä»¥ä¸‹ä½¿ç”¨ä¸€å¼ é•¿ä»£ç å—è¿›è¡Œå±•ç¤º) /** * EntrySet ç±»å®šä¹‰ */ private final class EntrySet extends AbstractSet { public Iterator iterator() { return newEntryIterator(); // è¿™é‡Œè¿”å› newEntryInteatorï¼Œè¿™é‡Œæ˜¯ç¥æ¥ä¹‹ç¬” } // ä¸ºèŠ‚çœç¯‡å¹…ï¼Œçœç•¥å…¶ä»–éƒ¨åˆ†æ–¹æ³• } /** * newEntryIterator æ˜¯HashMapä¸‹çš„æ–¹æ³• * åšçš„äº‹æƒ…å’Œæ–¹æ³•åå­—ä¸€æ ·ï¼Œnew ä¸€ä¸ª EntryIterator å¯¹è±¡ */ Iterator newEntryIterator() { return new EntryIterator(); } /** * EntryIterator æ˜¯ HashIterator çš„å­ç±»ï¼Œ * ä»…ä»…é‡å†™äº†next()æ–¹æ³•ï¼Œ * è€Œnextæ–¹æ³•ä¸­è°ƒç”¨çš„nextEntry()ï¼Œå…¶å®ä¹Ÿå±äº HashIterator */ private final class EntryIterator extends HashIterator { public Map.Entry next() { return nextEntry(); // æ˜¯ä¸æ˜¯æœ‰ç‚¹çœ¼ç†Ÿ? } } /** * HashIterator æ˜¯ Iterator çš„å­ç±» * é‡ç‚¹çœ‹ æ„é€ å‡½æ•° å’Œ nextEntry() æ–¹æ³• */ private abstract class HashIterator implements Iterator { Entry next; // next entry to return int expectedModCount; // For fast-fail int index; // current slot Entry current; // current entry HashIterator() { expectedModCount = modCount; // è¿™é‡Œå¯¹ expectedModCount èµ‹å€¼ï¼Œéå†æ—¶åšæ ¡éªŒ if (size > 0) { // advance to first entry /***************************************/ Entry[] t = table; /***************************************/ // çœ‹è¿™é‡Œ! çœ‹è¿™é‡Œ! çœ‹è¿™é‡Œ! // çœ‹è¿™é‡Œ! çœ‹è¿™é‡Œ! çœ‹è¿™é‡Œ! // çœ‹è¿™é‡Œ! çœ‹è¿™é‡Œ! çœ‹è¿™é‡Œ! // t æ˜¯ tableï¼Œ è€Œ table å°±æ˜¯ HashTable ç”¨æ¥å­˜æ”¾æ•°æ®çš„å‘€!!!! // ä¹Ÿå°±æ˜¯è¯´åº•å±‚å®é™…ä¸Šæ˜¯å…±ç”¨çš„ä¸€å¥—æ•°æ®ï¼ // è¿™ä¸€è¡Œä¹Ÿå¾ˆæœ‰æ„æ€ï¼Œ advance to first entry // ç§»åˆ°åœ°ä¸€ä¸ªentryï¼Œè¿™é‡Œæ‰€æŒ‡å‘çš„ entry å’Œ put è¿› map çš„é¡ºåºæ²¡æœ‰å…³ç³» // index æœ€ç»ˆçš„å€¼ä¸º å“ˆå¸Œæ¡¶ä¸­æœ€å°çš„éç©ºæ¡¶çš„ä¸‹æ ‡ while (index < t.length && (next = t[index++]) == null) ; } } public final boolean hasNext() { return next != null; } /** * nextEntry() * EntryIterator çš„ next() æœ€ç»ˆè°ƒç”¨çš„æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯è¿­ä»£å™¨çš„è¿”å›å€¼ * * */ final Entry nextEntry() { // è¿™é‡Œæ¯”è¾ƒäº† modCount å’Œ expectedModCountçš„å–å€¼ï¼Œå¦‚æœä¸åŒåˆ™æŠ›å‡ºå¼‚å¸¸ // expectedModCount åœ¨ HashIterator çš„æ„é€ å™¨é‡Œèµ‹å€¼ï¼Œ åˆå§‹å€¼å°±æ˜¯ modCount // è€Œ modCount åœ¨ HashMap è¿›è¡Œå…ƒç´ æ”¹å˜æ—¶å€™ä¼šè¿›è¡Œ ++ æ“ä½œ // å½“ç„¶è¿™å¹¶æ²¡ä»€ä¹ˆé¸Ÿç”¨ï¼Œå› ä¸ºå®Œå…¨å¯ä»¥å…ˆæ ¡éªŒè¿‡å†åŒæ—¶çº¿ç¨‹è¿›å…¥ç«äº‰åŒº é€ƒ( // if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry e = next; if (e == null) throw new NoSuchElementException(); // å…ˆçœ‹å½“å‰å“ˆå¸Œæ¡¶ä¸­æ˜¯å¦å·²ç»åˆ°é“¾è¡¨æœ«å°¾ // å¦‚æœæ˜¯çš„è¯å°±æ‰¾ä¸‹ä¸€ä¸ªå“ˆå¸Œæ¡¶ï¼Œç›´åˆ° table ä¸­æœ€åä¸€ä¸ªå“ˆå¸Œæ¡¶ä¸­çš„é“¾è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´  if ((next = e.next) == null) { Entry[] t = table; while (index < t.length && (next = t[index++]) == null) ; } current = e; return e; } // ä¸ºäº†èŠ‚çœç¯‡å¹…ï¼Œå‡å»äº†ä¸€äº›ä¸å¿…è¦çš„ä»£ç  } å…¶ä»–æœ€é‡è¦çš„ç²¾åå‰é¢å·²ç»è®²è¿‡ï¼Œè¿˜å‰©ä¸‹ä¸€äº›å…¶ä»–é›¶æ•£çš„ç‚¹ï¼Œ getgetæ–¹æ³•ï¼Œæœ¬è´¨ä¸Šè°ƒç”¨çš„getEntryæ–¹æ³•ï¼Œæ¯”è¾ƒç®€å•ï¼Œä¸å…·ä½“ä»‹ç»äº† /** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * * More formally, if this map contains a mapping from a key * {@code k} to a value {@code v} such that {@code (key==null ? k==null : * key.equals(k))}, then this method returns {@code v}; otherwise * it returns {@code null}. (There can be at most one such mapping.) * * A return value of {@code null} does not necessarily * indicate that the map contains no mapping for the key; it's also * possible that the map explicitly maps the key to {@code null}. * The {@link #containsKey containsKey} operation may be used to * distinguish these two cases. * * @see #put(Object, Object) */ public V get(Object key) { if (key == null) return getForNullKey(); Entry entry = getEntry(key); return null == entry ? null : entry.getValue(); } /** * Returns the entry associated with the specified key in the * HashMap. Returns null if the HashMap contains no mapping * for the key. */ final Entry getEntry(Object key) { if (size == 0) { return null; } int hash = (key == null) ? 0 : hash(key); for (Entry e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } return null; } cloneå…‹éš†æ–¹æ³•ï¼Œæ³¨é‡Šå†™å¾—å¾ˆæ¸…æ¥šäº†Returns a shallow copyï¼Œæ¯”è¾ƒå±é™©çš„æ–¹æ³•ï¼Œä¸æ¨èä½¿ç”¨ /** * Returns a shallow copy of this HashMap instance: the keys and * values themselves are not cloned. * * @return a shallow copy of this map */ public Object clone() { HashMap result = null; try { result = (HashMap)super.clone(); } catch (CloneNotSupportedException e) { // assert false; } if (result.table != EMPTY_TABLE) { result.inflateTable(Math.min( (int) Math.min( size * Math.min(1 / loadFactor, 4.0f), // we have limits... HashMap.MAXIMUM_CAPACITY), table.length)); } result.entrySet = null; result.modCount = 0; result.size = 0; result.init(); result.putAllForCreate(this); return result; } Another HashMap Constructoræ³¨ï¼Œè¿™é‡Œæ˜¯ä½¿ç”¨äº†putAllForCreateï¼Œä½¿ç”¨äº†shallow copyï¼Œä¸æ¨èè¿™æ ·åš /** * Constructs a new HashMap with the same mappings as the * specified Map. The HashMap is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified Map. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */ public HashMap(Map m) { this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); inflateTable(threshold); putAllForCreate(m); } diamond types are not supported at this language levelåœ¨è°ƒè¯•æ—¶ï¼ŒæŠŠHashMapæºç å…¨éƒ¨å¤åˆ¶å‡ºæ¥ï¼Œç»“æœç¼–è¯‘ä¸è¿‡ï¼Œå‘ŠçŸ¥ diamond types are not supported at this language level void createEntry(int hash, K key, V value, int bucketIndex) { Entry e = table[bucketIndex]; table[bucketIndex] = new Entry(hash, key, value, e); // å°±æ˜¯è¿™ä¸€è¡Œ // â†‘â†‘â†‘â†‘ // here // size++; } ç»è¿‡æœç´¢ï¼Œå‘ç°å…¶å®æ˜¯é¡¹ç›®æ‰€ä½¿ç”¨çš„æ˜¯language level 6ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºè¿›è¡Œä¿®æ”¹å³å¯ mystical transient?åœ¨å¤åˆ¶æºç çš„æ—¶å€™ï¼Œå‘ç°åœ¨å…¨é€‰çš„æƒ…å†µä¸‹ï¼Œä¸€ä¸‹ä¸¤è¡Œæ²¡æœ‰è¢«å¤åˆ¶è¿‡æ¥ï¼Œéš¾é“è¿™å’Œtransientæœ‰å…³ç³»ï¼Ÿï¼Ÿï¼Ÿä½†æ˜¯åŒæ ·è¢«transientä¿®é¥°çš„entrySetå´è¢«å¤åˆ¶äº†è¿‡æ¥ï¼Œæ˜æ˜éƒ½æ˜¯Ctrl-C Ctrl-Vä¸ºå•¥æœ‰åŒºåˆ«å˜ =ã€‚= transient volatile Set keySet = null; // æˆ‘æ²¡æœ‰è¢«å¤åˆ¶å“¦ transient volatile Collection values = null; // æˆ‘æ²¡æœ‰è¢«å¤åˆ¶å“¦ private transient Set entrySet = null; // æˆ‘è¢«å¤åˆ¶äº†å“¦ å°ç»“HashMapæ˜¯ä¸€ä¸ªå¾ˆå¼ºå¤§çš„é›†åˆç±»ï¼Œå°ç»“ä¸€ä¸‹: å…¶ä¸­ä½¿ç”¨Hashå‡½æ•°è¿›è¡Œè¾ƒå¿«çš„æ£€ç´¢ï¼Œåœ¨hashå†²çªæ—¶ä½¿ç”¨é“¾è¡¨è¿›è¡Œæ•°æ®çš„å­˜å‚¨ å½“å†…éƒ¨ç©ºé—´ä¸è¶³æ—¶ï¼Œä¼šè‡ªåŠ¨è¿›è¡Œæ‰©å®¹ï¼Œæ‰©å®¹é•¿åº¦ä¸ºåŸæ¥çš„2å€ï¼Œå¹¶ä¸”ä¼šå°†æ—§çš„æ•°æ®å…¨éƒ¨æ˜ å°„åˆ°æ–°æ•°æ®ä¸Šï¼Œå½“HashMapé•¿åº¦è¾ƒå¤§æ—¶ï¼Œå†è¿›è¡Œæ‰©å±•å¼€é”€ä¼šæ¯”è¾ƒå¤§ éå†HashMapæ—¶ï¼Œæœ€å¥½ä½¿ç”¨EntrySet()è¿›è¡Œéå†ï¼Œä½¿ç”¨çš„æ—¶å€™æ³¨æ„æ–¹æ³•The set supports element removal, which removes the corresponding mapping from the map,via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations.It does not support the add or addAll operations.","categories":[{"name":"Java","slug":"Java","permalink":"http://kevingeek.github.io/categories/Java/"}],"tags":[{"name":"Collection","slug":"Collection","permalink":"http://kevingeek.github.io/tags/Collection/"}]},{"title":"MarkDown å†™æ³•ä¹±å¼¹","slug":"MarkDown","date":"2016-07-25T13:17:17.000Z","updated":"2020-04-09T04:19:33.057Z","comments":true,"path":"2016/07/25/MarkDown/","link":"","permalink":"http://kevingeek.github.io/2016/07/25/MarkDown/","excerpt":"è¿™æ˜¯è¶…é“¾æ¥å¤‡å¿˜å…¨åœ¨è¿™ä¸Šé¢MarkDownè¯­æ³•","text":"è¿™æ˜¯è¶…é“¾æ¥å¤‡å¿˜å…¨åœ¨è¿™ä¸Šé¢MarkDownè¯­æ³• This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. æ ‡é¢˜å“¦ This is an H1This is an H2ç¬¬ä¸€æ¬¡æ¥è¿™è¾¹å†™æ—¥å¿—ï¼Œç®—æ˜¯ç¬¬ä¸€ç¯‡çœŸæ­£æ„ä¹‰ä¸Šçš„ä¸ªäººblogæ—¥å¿—ï¼Œå¥½çš„å¼€å§‹ï¼ŒHello Worldï¼ Use the printf() function. ä»¥ä¸‹æ˜¯Javaä»£ç  System.out.println(\"hello world!\"); è¿™æ˜¯å¾ˆé‡è¦çš„ line_number line_two æ©ï¼Œè¿™æ˜¯æ˜Ÿå· æ©ï¼Œè¿™æ˜¯åŠ å· åˆ†å‰²ç¬¦ ç¬¬ä¸€ç‚¹ ç¬¬äºŒç‚¹","categories":[{"name":"feel","slug":"feel","permalink":"http://kevingeek.github.io/categories/feel/"}],"tags":[{"name":"First","slug":"First","permalink":"http://kevingeek.github.io/tags/First/"},{"name":"Second","slug":"Second","permalink":"http://kevingeek.github.io/tags/Second/"}]}]}